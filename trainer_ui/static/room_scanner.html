<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Room Scanner - ContinuonXR</title>
    <link rel="stylesheet" href="/static/shared-nav.css">
    <script src="/static/shared-nav.js"></script>
    <!-- Three.js for 3D room preview -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a1a;
            color: #eee;
            min-height: 100vh;
        }

        .header {
            background: #12122a;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #1a1a3a;
        }

        .header h1 {
            font-size: 1.5rem;
            color: #4ade80;
        }

        .header h1 span {
            color: #888;
            font-weight: normal;
            font-size: 0.9rem;
        }

        .nav-links {
            display: flex;
            gap: 1rem;
        }

        .nav-links a {
            color: #4ade80;
            text-decoration: none;
            font-size: 0.9rem;
        }

        .nav-links a:hover {
            text-decoration: underline;
        }

        .main {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            padding: 1.5rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        @media (max-width: 900px) {
            .main {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: #12122a;
            border-radius: 12px;
            padding: 1.5rem;
        }

        .panel h3 {
            color: #4ade80;
            font-size: 1.1rem;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .camera-section {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .camera-container {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 4/3;
        }

        #camera-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #capture-canvas {
            display: none;
        }

        #boundary-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .guided-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding: 1rem;
            display: none;
        }

        .guided-overlay.active {
            display: block;
        }

        .guidance-text {
            color: #4ade80;
            font-size: 1rem;
            font-weight: 500;
            text-align: center;
            margin-bottom: 0.5rem;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        }

        .coverage-bar {
            display: flex;
            gap: 4px;
            justify-content: center;
        }

        .coverage-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.25rem 0.5rem;
            background: rgba(0,0,0,0.5);
            border-radius: 4px;
            font-size: 0.7rem;
        }

        .coverage-item .label {
            color: #888;
        }

        .coverage-item .value {
            font-weight: bold;
            color: #e94560;
        }

        .coverage-item .value.good {
            color: #fbbf24;
        }

        .coverage-item .value.great {
            color: #4ade80;
        }

        .quality-ring {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 4px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            background: rgba(0,0,0,0.7);
        }

        .quality-ring.low { border-color: #e94560; color: #e94560; }
        .quality-ring.medium { border-color: #fbbf24; color: #fbbf24; }
        .quality-ring.high { border-color: #4ade80; color: #4ade80; }

        /* Camera Movement Guidance Overlay */
        .camera-guide-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            display: none;
            z-index: 10;
        }

        .camera-guide-overlay.active {
            display: block;
        }

        /* Landscape orientation reminder */
        .orientation-reminder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(233, 69, 96, 0.95);
            padding: 1.5rem 2rem;
            border-radius: 12px;
            text-align: center;
            display: none;
            z-index: 20;
        }

        .orientation-reminder.show {
            display: block;
            animation: pulse 1.5s infinite;
        }

        .orientation-reminder .icon {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            animation: rotatePhone 2s ease-in-out infinite;
        }

        @keyframes rotatePhone {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .orientation-reminder p {
            color: white;
            font-weight: 600;
            margin: 0;
        }

        /* Direction arrows */
        .direction-arrow {
            position: absolute;
            font-size: 2.5rem;
            color: #4ade80;
            text-shadow: 0 2px 8px rgba(0,0,0,0.8);
            animation: arrowPulse 1s ease-in-out infinite;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .direction-arrow.active {
            opacity: 1;
        }

        .direction-arrow.left { left: 10px; top: 50%; transform: translateY(-50%); }
        .direction-arrow.right { right: 10px; top: 50%; transform: translateY(-50%); }
        .direction-arrow.up { top: 10px; left: 50%; transform: translateX(-50%); }
        .direction-arrow.down { bottom: 60px; left: 50%; transform: translateX(-50%); }

        @keyframes arrowPulse {
            0%, 100% { transform: translateY(-50%) scale(1); }
            50% { transform: translateY(-50%) scale(1.2); }
        }

        .direction-arrow.up, .direction-arrow.down {
            animation: arrowPulseVertical 1s ease-in-out infinite;
        }

        @keyframes arrowPulseVertical {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.2); }
        }

        /* Movement instruction banner */
        .movement-instruction {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 0.6rem 1.2rem;
            border-radius: 20px;
            border: 2px solid #4ade80;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            max-width: 90%;
        }

        .movement-instruction .icon {
            font-size: 1.5rem;
        }

        .movement-instruction .text {
            color: #4ade80;
            font-weight: 600;
            font-size: 0.95rem;
            white-space: nowrap;
        }

        /* Target area grid overlay */
        .target-grid {
            position: absolute;
            top: 15%;
            left: 10%;
            right: 10%;
            bottom: 25%;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            opacity: 0.7;
        }

        .target-cell {
            border: 2px dashed transparent;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            color: transparent;
            transition: all 0.3s;
        }

        .target-cell.needs-scan {
            border-color: #fbbf24;
            background: rgba(251, 191, 36, 0.1);
            color: #fbbf24;
        }

        .target-cell.scanned {
            border-color: #4ade80;
            background: rgba(74, 222, 128, 0.1);
        }

        .target-cell.scanned::after {
            content: '‚úì';
            color: #4ade80;
            font-size: 1.5rem;
        }

        .target-cell.current {
            border-color: #60a5fa;
            border-style: solid;
            border-width: 3px;
            background: rgba(96, 165, 250, 0.2);
            animation: targetPulse 1s ease-in-out infinite;
        }

        @keyframes targetPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(96, 165, 250, 0.4); }
            50% { box-shadow: 0 0 0 10px rgba(96, 165, 250, 0); }
        }

        /* Scan progress indicator */
        .scan-progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: rgba(0,0,0,0.5);
        }

        .scan-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #60a5fa);
            width: 0%;
            transition: width 0.3s;
        }

        .mode-toggle {
            display: flex;
            background: #1a1a3a;
            border-radius: 6px;
            padding: 3px;
            gap: 3px;
        }

        .mode-btn {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            background: transparent;
            color: #888;
            transition: all 0.2s;
        }

        .mode-btn.active {
            background: #4ade80;
            color: #000;
        }

        .auto-capture-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            border: 4px solid #4ade80;
            border-radius: 50%;
            animation: captureRing 0.5s ease-out;
            pointer-events: none;
            display: none;
        }

        @keyframes captureRing {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
        }

        .camera-controls {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .camera-select {
            background: #1e293b;
            color: #e2e8f0;
            border: 1px solid #334155;
            border-radius: 6px;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            min-width: 200px;
            cursor: pointer;
        }

        .camera-select:hover {
            border-color: #4ade80;
        }

        .camera-select:focus {
            outline: none;
            border-color: #4ade80;
            box-shadow: 0 0 0 2px rgba(74, 222, 128, 0.2);
        }

        .camera-select option {
            background: #1e293b;
            color: #e2e8f0;
        }

        .btn {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: #4ade80;
            color: #000;
        }

        .btn-primary:hover {
            background: #5beef91;
        }

        .btn-primary:disabled {
            background: #2a4a3a;
            color: #666;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: #1a1a3a;
            color: #fff;
        }

        .btn-secondary:hover {
            background: #2a2a4a;
        }

        .btn-danger {
            background: #e94560;
            color: #fff;
        }

        .btn-danger:hover {
            background: #f45a75;
        }

        .upload-area {
            border: 2px dashed #333;
            border-radius: 8px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .upload-area:hover {
            border-color: #4ade80;
            background: rgba(74, 222, 128, 0.05);
        }

        .upload-area.dragover {
            border-color: #4ade80;
            background: rgba(74, 222, 128, 0.1);
        }

        .upload-area p {
            color: #888;
            margin-bottom: 0.5rem;
        }

        .upload-area input {
            display: none;
        }

        .captured-images {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .captured-image {
            position: relative;
            border-radius: 6px;
            overflow: hidden;
            aspect-ratio: 4/3;
            background: #1a1a3a;
        }

        .captured-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .captured-image .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(233, 69, 96, 0.9);
            color: #fff;
            border: none;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .captured-image .image-number {
            position: absolute;
            bottom: 4px;
            left: 4px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .image-count {
            font-size: 0.85rem;
            color: #888;
        }

        .scan-status {
            padding: 1rem;
            background: #1a1a3a;
            border-radius: 6px;
            margin-top: 1rem;
        }

        .scan-status.processing {
            border-left: 3px solid #fbbf24;
        }

        .scan-status.success {
            border-left: 3px solid #4ade80;
        }

        .scan-status.error {
            border-left: 3px solid #e94560;
        }

        .progress-bar {
            height: 4px;
            background: #1a1a3a;
            border-radius: 2px;
            margin-top: 0.5rem;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #4ade80;
            border-radius: 2px;
            transition: width 0.3s;
        }

        .results-section {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .result-item {
            background: #1a1a3a;
            border-radius: 6px;
            padding: 1rem;
        }

        .result-item h4 {
            color: #4ade80;
            font-size: 0.9rem;
            margin-bottom: 0.75rem;
        }

        .asset-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .asset-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            border-bottom: 1px solid #2a2a4a;
        }

        .asset-item:last-child {
            border-bottom: none;
        }

        .asset-type {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .asset-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .asset-info {
            color: #888;
            font-size: 0.8rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .stat-item {
            text-align: center;
            padding: 0.75rem;
            background: #0a0a1a;
            border-radius: 6px;
        }

        .stat-value {
            font-size: 1.5rem;
            color: #4ade80;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #888;
            margin-top: 0.25rem;
        }

        .scan-history {
            margin-top: 1rem;
        }

        .scan-history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: #1a1a3a;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .scan-history-item:hover {
            background: #2a2a4a;
        }

        .scan-time {
            color: #888;
            font-size: 0.8rem;
        }

        .camera-permission {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: #888;
            text-align: center;
        }

        .camera-permission p {
            margin-bottom: 1rem;
        }

        .hidden {
            display: none !important;
        }

        /* Full Auto Mode Styles */
        .full-auto-layout {
            grid-template-columns: 1fr 1fr 1fr;
        }

        @media (max-width: 1200px) {
            .full-auto-layout {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 900px) {
            .full-auto-layout {
                grid-template-columns: 1fr;
            }
        }

        .room-preview-panel {
            background: #12122a;
            border-radius: 12px;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            min-height: 400px;
        }

        .room-preview-panel h3 {
            color: #4ade80;
            font-size: 1.1rem;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-3d-container {
            flex: 1;
            background: #0a0a1a;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            min-height: 300px;
        }

        #room-preview-canvas {
            width: 100%;
            height: 100%;
        }

        .preview-controls {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .preview-legend {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 0.75rem;
            font-size: 0.75rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .coverage-3d-panel {
            background: #1a1a3a;
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .coverage-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .coverage-cell {
            aspect-ratio: 1;
            background: #2a2a4a;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .coverage-cell.captured {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
        }

        .coverage-cell.partial {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        }

        .coverage-cell .cell-label {
            font-size: 0.65rem;
            color: #aaa;
        }

        .coverage-cell.captured .cell-label,
        .coverage-cell.partial .cell-label {
            color: #000;
        }

        .auto-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: #1a1a3a;
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #666;
        }

        .status-dot.active {
            background: #4ade80;
            animation: pulse 1.5s infinite;
        }

        .status-dot.processing {
            background: #fbbf24;
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .capture-log {
            max-height: 150px;
            overflow-y: auto;
            background: #0a0a1a;
            border-radius: 6px;
            padding: 0.75rem;
            font-size: 0.75rem;
            font-family: monospace;
        }

        .log-entry {
            padding: 0.25rem 0;
            border-bottom: 1px solid #1a1a3a;
            display: flex;
            justify-content: space-between;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-time {
            color: #666;
        }

        .log-msg {
            color: #4ade80;
        }

        .log-msg.error {
            color: #e94560;
        }

        .camera-position-indicator {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.75rem;
            z-index: 10;
        }
    </style>
</head>
<body>
    <main class="main">
        <div class="panel camera-section">
            <h3>
                Capture Images
                <div style="display:flex;align-items:center;gap:1rem;">
                    <div class="mode-toggle">
                        <button class="mode-btn active" id="mode-manual" onclick="setMode('manual')">Manual</button>
                        <button class="mode-btn" id="mode-guided" onclick="setMode('guided')">Guided</button>
                        <button class="mode-btn" id="mode-fullauto" onclick="setMode('fullauto')">üöÄ Full Auto</button>
                    </div>
                    <span class="image-count" id="image-count">0 images</span>
                </div>
            </h3>

            <!-- Camera View -->
            <div class="camera-container" id="camera-container">
                <video id="camera-video" autoplay playsinline></video>
                <canvas id="capture-canvas"></canvas>
                <canvas id="boundary-canvas"></canvas>

                <!-- Quality Ring (Guided Mode) -->
                <div class="quality-ring low hidden" id="quality-ring">0%</div>

                <!-- Auto-capture indicator -->
                <div class="auto-capture-indicator" id="auto-capture-indicator"></div>

                <!-- Guided Mode Overlay -->
                <div class="guided-overlay" id="guided-overlay">
                    <div class="guidance-text" id="guidance-text">Point camera at the room</div>
                    <div class="coverage-bar">
                        <div class="coverage-item">
                            <span class="label">Floor</span>
                            <span class="value" id="cov-floor">0%</span>
                        </div>
                        <div class="coverage-item">
                            <span class="label">Ceiling</span>
                            <span class="value" id="cov-ceiling">0%</span>
                        </div>
                        <div class="coverage-item">
                            <span class="label">L Wall</span>
                            <span class="value" id="cov-wall-left">0%</span>
                        </div>
                        <div class="coverage-item">
                            <span class="label">R Wall</span>
                            <span class="value" id="cov-wall-right">0%</span>
                        </div>
                        <div class="coverage-item">
                            <span class="label">Corners</span>
                            <span class="value" id="cov-corners">0%</span>
                        </div>
                    </div>
                </div>

                <div class="camera-permission hidden" id="camera-permission">
                    <p>Camera access needed for live capture</p>
                    <button class="btn btn-primary" onclick="startCamera()">Enable Camera</button>
                </div>

                <!-- Camera Movement Guide Overlay -->
                <div class="camera-guide-overlay" id="camera-guide-overlay">
                    <!-- Landscape orientation reminder -->
                    <div class="orientation-reminder" id="orientation-reminder">
                        <div class="icon">üì±</div>
                        <p>Rotate to Landscape</p>
                        <p style="font-size:0.85rem;opacity:0.9;margin-top:0.25rem;">for better room coverage</p>
                    </div>

                    <!-- Movement instruction banner -->
                    <div class="movement-instruction" id="movement-instruction">
                        <span class="icon">üì∑</span>
                        <span class="text" id="movement-text">Slowly pan camera across the room</span>
                    </div>

                    <!-- Direction arrows -->
                    <div class="direction-arrow left" id="arrow-left">‚óÄ</div>
                    <div class="direction-arrow right" id="arrow-right">‚ñ∂</div>
                    <div class="direction-arrow up" id="arrow-up">‚ñ≤</div>
                    <div class="direction-arrow down" id="arrow-down">‚ñº</div>

                    <!-- Target area grid -->
                    <div class="target-grid" id="target-grid">
                        <div class="target-cell" data-area="top-left"></div>
                        <div class="target-cell" data-area="top-center"></div>
                        <div class="target-cell" data-area="top-right"></div>
                        <div class="target-cell" data-area="middle-left"></div>
                        <div class="target-cell" data-area="middle-center"></div>
                        <div class="target-cell" data-area="middle-right"></div>
                        <div class="target-cell" data-area="bottom-left"></div>
                        <div class="target-cell" data-area="bottom-center"></div>
                        <div class="target-cell" data-area="bottom-right"></div>
                    </div>

                    <!-- Progress bar -->
                    <div class="scan-progress-bar">
                        <div class="scan-progress-fill" id="scan-progress-fill"></div>
                    </div>
                </div>
            </div>

            <!-- Camera Controls -->
            <div class="camera-controls">
                <select id="camera-select" class="camera-select" onchange="onCameraChange()">
                    <option value="">Select Camera...</option>
                </select>
                <button class="btn btn-primary" id="capture-btn" onclick="capturePhoto()" disabled>
                    <span>üì∏</span> Capture Photo
                </button>
                <button class="btn btn-secondary" id="toggle-camera-btn" onclick="toggleCamera()">
                    <span>üé•</span> Start Camera
                </button>
                <button class="btn btn-secondary hidden" id="auto-capture-btn" onclick="toggleAutoCapture()">
                    <span>ü§ñ</span> Auto-Capture: OFF
                </button>
                <button class="btn btn-danger" onclick="clearImages()" id="clear-btn" disabled>
                    <span>üóëÔ∏è</span> Clear All
                </button>
            </div>

            <!-- Upload Area -->
            <div class="upload-area" id="upload-area" onclick="document.getElementById('file-input').click()">
                <p>üìÅ Drag & drop images here or click to upload</p>
                <p style="font-size:0.8rem;">Supports JPG, PNG, WebP</p>
                <input type="file" id="file-input" accept="image/*" multiple onchange="handleFileUpload(event)">
            </div>

            <!-- Captured Images Preview -->
            <div class="captured-images" id="captured-images">
                <!-- Dynamically populated -->
            </div>

            <!-- Scan Button -->
            <button class="btn btn-primary" style="width:100%;margin-top:1rem;" id="scan-btn" onclick="startScan()" disabled>
                <span>üîç</span> Scan Room & Generate 3D Assets
            </button>

            <!-- Scan Status -->
            <div class="scan-status hidden" id="scan-status">
                <div id="status-text">Processing...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill" style="width:0%"></div>
                </div>
            </div>
        </div>

        <div class="panel results-section">
            <h3>Scan Results</h3>

            <!-- Stats -->
            <div class="stats-grid" id="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="stat-objects">-</div>
                    <div class="stat-label">Objects Detected</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-assets">-</div>
                    <div class="stat-label">3D Assets</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-images">-</div>
                    <div class="stat-label">Images Processed</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-time">-</div>
                    <div class="stat-label">Processing Time</div>
                </div>
            </div>

            <!-- Generated Assets -->
            <div class="result-item" id="assets-result">
                <h4>Generated 3D Assets</h4>
                <div class="asset-list" id="asset-list">
                    <p style="color:#888;text-align:center;padding:1rem;">No assets generated yet</p>
                </div>
            </div>

            <!-- Room Dimensions -->
            <div class="result-item" id="room-result">
                <h4>Room Dimensions</h4>
                <div id="room-dimensions">
                    <p style="color:#888;text-align:center;padding:1rem;">Scan room to detect dimensions</p>
                </div>
            </div>

            <!-- Export Actions -->
            <div style="display:flex;gap:0.75rem;flex-wrap:wrap;">
                <button class="btn btn-secondary" onclick="exportJSON()" id="export-json-btn" disabled>
                    <span>üìÑ</span> Export JSON
                </button>
                <button class="btn btn-secondary" onclick="loadInSimulator()" id="load-sim-btn" disabled>
                    <span>üéÆ</span> Load in Simulator
                </button>
            </div>

            <!-- Scan History -->
            <div class="scan-history">
                <h4 style="color:#888;font-size:0.9rem;margin-bottom:0.75rem;">Recent Scans</h4>
                <div id="scan-history-list">
                    <p style="color:#666;font-size:0.85rem;">No previous scans</p>
                </div>
            </div>
        </div>

        <!-- 3D Room Preview Panel (shown in Full Auto mode) -->
        <div class="panel room-preview-panel hidden" id="room-preview-panel">
            <h3>
                3D Room Preview
                <span style="font-size:0.8rem;color:#888;" id="preview-status">Waiting...</span>
            </h3>

            <!-- Auto Status -->
            <div class="auto-status" id="auto-status">
                <div class="status-dot" id="status-dot"></div>
                <span id="auto-status-text">Ready to start</span>
            </div>

            <!-- 3D Preview Canvas -->
            <div class="preview-3d-container">
                <canvas id="room-preview-canvas"></canvas>
                <div class="camera-position-indicator" id="camera-position">
                    üì∑ Camera: Front Center
                </div>
            </div>

            <!-- Legend -->
            <div class="preview-legend">
                <div class="legend-item">
                    <div class="legend-dot" style="background:#4ade80;"></div>
                    <span>Captured</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background:#60a5fa;"></div>
                    <span>Furniture</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background:#fbbf24;"></div>
                    <span>Pending</span>
                </div>
                <div class="legend-item">
                    <div class="legend-dot" style="background:#e94560;"></div>
                    <span>Camera</span>
                </div>
            </div>

            <!-- Coverage Grid (top-down view) -->
            <div class="coverage-3d-panel">
                <h4 style="color:#888;font-size:0.85rem;margin-bottom:0.75rem;">Room Coverage (Top View)</h4>
                <div class="coverage-grid" id="coverage-grid">
                    <div class="coverage-cell" data-area="back-left"><span class="cell-label">Back L</span></div>
                    <div class="coverage-cell" data-area="back-center"><span class="cell-label">Back</span></div>
                    <div class="coverage-cell" data-area="back-right"><span class="cell-label">Back R</span></div>
                    <div class="coverage-cell" data-area="left"><span class="cell-label">Left</span></div>
                    <div class="coverage-cell" data-area="center"><span class="cell-label">Center</span></div>
                    <div class="coverage-cell" data-area="right"><span class="cell-label">Right</span></div>
                    <div class="coverage-cell" data-area="front-left"><span class="cell-label">Front L</span></div>
                    <div class="coverage-cell" data-area="front-center"><span class="cell-label">Front</span></div>
                    <div class="coverage-cell" data-area="front-right"><span class="cell-label">Front R</span></div>
                </div>
            </div>

            <!-- Preview Controls -->
            <div class="preview-controls">
                <button class="btn btn-primary" id="start-auto-btn">
                    <span>‚ñ∂Ô∏è</span> Start Scanning
                </button>
                <button class="btn btn-secondary" onclick="resetRoomPreview()">
                    <span>üîÑ</span> Reset
                </button>
                <button class="btn btn-secondary" onclick="exportRoom3D()">
                    <span>üíæ</span> Export GLB
                </button>
            </div>

            <!-- Capture Log -->
            <div style="margin-top:1rem;">
                <h4 style="color:#888;font-size:0.85rem;margin-bottom:0.5rem;">Capture Log</h4>
                <div class="capture-log" id="capture-log">
                    <div class="log-entry">
                        <span class="log-time">--:--:--</span>
                        <span class="log-msg">Waiting for Full Auto to start...</span>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // State
        let capturedImages = [];
        let cameraStream = null;
        let lastScanResult = null;
        let availableCameras = [];
        let selectedCameraId = null;
        let oakdAvailable = false;
        let oakdRunning = false;
        let oakdCaptureInterval = null;

        // Full Auto Mode State
        let fullAutoActive = false;
        let fullAutoInterval = null;
        let lastFrameHash = null;
        let stableFrameCount = 0;
        let processingQueue = [];
        let isProcessing = false;
        let roomCoverage = {
            'back-left': 0, 'back-center': 0, 'back-right': 0,
            'left': 0, 'center': 0, 'right': 0,
            'front-left': 0, 'front-center': 0, 'front-right': 0
        };
        let generatedAssets3D = [];
        let capturePositions = [];

        // Captured frames with depth for 3D reconstruction
        let capturedFrames = [];  // {rgb: base64, depth: base64, position: {x,y,z}, area: string}
        let scanComplete = false;
        let reconstructionMesh = null;
        let panoramaTexture = null;
        let currentViewMode = 'wireframe';  // 'wireframe', 'textured', 'depth', 'panorama'

        // Three.js State
        let threeScene = null;
        let threeCamera = null;
        let threeRenderer = null;
        let threeControls = null;
        let roomBox = null;
        let assetMeshes = [];
        let cameraMarker = null;
        let captureMarkers = [];

        // Camera enumeration - includes both browser cameras and OAK-D
        async function enumerateCameras() {
            const select = document.getElementById('camera-select');
            select.innerHTML = '<option value="">Select Camera...</option>';
            availableCameras = [];

            // Check for OAK-D cameras first
            try {
                const oakdResponse = await fetch('/oakd/status');
                const oakdData = await oakdResponse.json();
                oakdAvailable = oakdData.available && oakdData.devices && oakdData.devices.length > 0;

                if (oakdAvailable) {
                    oakdData.devices.forEach((device, index) => {
                        const cameraObj = {
                            deviceId: `oakd:${index}`,
                            label: `OAK-D Lite (RGB + Depth)`,
                            isOakd: true
                        };
                        availableCameras.push(cameraObj);

                        const option = document.createElement('option');
                        option.value = cameraObj.deviceId;
                        option.text = cameraObj.label;
                        option.style.color = '#4ade80';  // Green for depth camera
                        select.appendChild(option);
                    });
                    console.log('OAK-D camera detected');
                }
            } catch (err) {
                console.log('OAK-D not available:', err.message);
            }

            // Then enumerate browser cameras
            try {
                const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
                tempStream.getTracks().forEach(track => track.stop());

                const devices = await navigator.mediaDevices.enumerateDevices();
                const browserCameras = devices.filter(device => device.kind === 'videoinput');

                browserCameras.forEach((camera, index) => {
                    const cameraObj = {
                        deviceId: camera.deviceId,
                        label: camera.label || `Camera ${index + 1}`,
                        isOakd: false
                    };
                    availableCameras.push(cameraObj);

                    const option = document.createElement('option');
                    option.value = camera.deviceId;
                    option.text = camera.label || `Camera ${index + 1}`;
                    select.appendChild(option);
                });
            } catch (err) {
                console.log('No browser cameras:', err.message);
            }

            // Auto-select first camera (prefer OAK-D)
            if (availableCameras.length > 0) {
                select.value = availableCameras[0].deviceId;
                selectedCameraId = availableCameras[0].deviceId;
                console.log(`Found ${availableCameras.length} camera(s)`);
            } else {
                console.warn('No cameras found');
            }

            return availableCameras;
        }

        function isOakdCamera(cameraId) {
            return cameraId && cameraId.startsWith('oakd:');
        }

        function onCameraChange() {
            const select = document.getElementById('camera-select');
            selectedCameraId = select.value;
            console.log('Selected camera:', selectedCameraId);

            // If camera is running, restart with new camera
            if (cameraStream || oakdRunning) {
                stopCamera();
                startCamera();
            }
        }

        // Guided mode state
        let scanMode = 'manual';  // 'manual' or 'guided'
        let guidedAnalysisInterval = null;
        let autoCapture = false;
        let lastGuidance = null;
        let totalCoverage = {
            floor: 0, ceiling: 0, wall_left: 0, wall_right: 0, corners: 0
        };
        let capturedViews = new Set();  // Track which views we've captured
        let lastAutoCapture = 0;  // Timestamp of last auto-capture

        // Camera movement guide state
        let cameraGuideActive = false;
        let targetAreasCovered = {
            'top-left': 0, 'top-center': 0, 'top-right': 0,
            'middle-left': 0, 'middle-center': 0, 'middle-right': 0,
            'bottom-left': 0, 'bottom-center': 0, 'bottom-right': 0
        };
        let currentTargetArea = 'middle-center';
        let scanSequence = [
            'middle-center', 'middle-left', 'middle-right',
            'top-center', 'top-left', 'top-right',
            'bottom-center', 'bottom-left', 'bottom-right'
        ];
        let scanSequenceIndex = 0;
        let lastMotionTime = 0;
        let isPortrait = false;

        // Mode switching
        function setMode(mode) {
            scanMode = mode;
            document.getElementById('mode-manual').classList.toggle('active', mode === 'manual');
            document.getElementById('mode-guided').classList.toggle('active', mode === 'guided');
            document.getElementById('mode-fullauto').classList.toggle('active', mode === 'fullauto');
            document.getElementById('guided-overlay').classList.toggle('active', mode === 'guided');
            document.getElementById('quality-ring').classList.toggle('hidden', mode === 'manual' || mode === 'fullauto');
            document.getElementById('auto-capture-btn').classList.toggle('hidden', mode === 'manual');

            // Show/hide 3D room preview panel for Full Auto mode
            const roomPreviewPanel = document.getElementById('room-preview-panel');
            const mainLayout = document.querySelector('.main');

            if (mode === 'fullauto') {
                roomPreviewPanel.classList.remove('hidden');
                mainLayout.classList.add('full-auto-layout');
                initThreeJSPreview();
                // Auto-start camera if not running
                if (!cameraStream && !oakdRunning) {
                    startCamera();
                }
            } else {
                roomPreviewPanel.classList.add('hidden');
                mainLayout.classList.remove('full-auto-layout');
                // Stop full auto if active
                if (fullAutoActive) {
                    stopFullAuto();
                }
            }

            if (mode === 'guided' && (cameraStream || oakdRunning)) {
                startGuidedAnalysis();
            } else {
                stopGuidedAnalysis();
                clearBoundaryCanvas();
            }

            // Activate camera movement guide for guided and fullauto modes
            if ((mode === 'guided' || mode === 'fullauto') && (cameraStream || oakdRunning)) {
                activateCameraGuide();
            } else {
                deactivateCameraGuide();
            }
        }

        function startGuidedAnalysis() {
            if (guidedAnalysisInterval) return;

            // Analyze frames at ~3 fps for guidance (balance between responsiveness and performance)
            guidedAnalysisInterval = setInterval(analyzeCurrentFrame, 333);
        }

        function stopGuidedAnalysis() {
            if (guidedAnalysisInterval) {
                clearInterval(guidedAnalysisInterval);
                guidedAnalysisInterval = null;
            }
        }

        // ============================================
        // Camera Movement Guide Functions
        // ============================================

        function activateCameraGuide() {
            cameraGuideActive = true;
            const overlay = document.getElementById('camera-guide-overlay');
            overlay.classList.add('active');

            // Check orientation
            checkOrientation();
            window.addEventListener('resize', checkOrientation);

            // Reset target areas
            resetTargetAreas();

            // Start the guidance sequence
            updateCameraGuide();

            console.log('[CameraGuide] Activated');
        }

        function deactivateCameraGuide() {
            cameraGuideActive = false;
            const overlay = document.getElementById('camera-guide-overlay');
            overlay.classList.remove('active');
            window.removeEventListener('resize', checkOrientation);
            console.log('[CameraGuide] Deactivated');
        }

        function checkOrientation() {
            const container = document.getElementById('camera-container');
            isPortrait = container.offsetHeight > container.offsetWidth;

            const reminder = document.getElementById('orientation-reminder');
            if (isPortrait && cameraGuideActive) {
                reminder.classList.add('show');
            } else {
                reminder.classList.remove('show');
            }
        }

        function resetTargetAreas() {
            targetAreasCovered = {
                'top-left': 0, 'top-center': 0, 'top-right': 0,
                'middle-left': 0, 'middle-center': 0, 'middle-right': 0,
                'bottom-left': 0, 'bottom-center': 0, 'bottom-right': 0
            };
            scanSequenceIndex = 0;
            currentTargetArea = scanSequence[0];
            updateTargetGrid();
        }

        function updateTargetGrid() {
            const cells = document.querySelectorAll('.target-cell');
            let scannedCount = 0;

            cells.forEach(cell => {
                const area = cell.dataset.area;
                const coverage = targetAreasCovered[area] || 0;

                cell.classList.remove('needs-scan', 'scanned', 'current');

                if (coverage >= 100) {
                    cell.classList.add('scanned');
                    scannedCount++;
                } else if (area === currentTargetArea) {
                    cell.classList.add('current');
                } else if (coverage < 50) {
                    cell.classList.add('needs-scan');
                }
            });

            // Update progress bar
            const progress = (scannedCount / 9) * 100;
            document.getElementById('scan-progress-fill').style.width = `${progress}%`;

            return scannedCount;
        }

        function updateCameraGuide() {
            if (!cameraGuideActive) return;

            // Update direction arrows based on current target
            updateDirectionArrows();

            // Update movement instruction
            updateMovementInstruction();

            // Update target grid
            const scannedCount = updateTargetGrid();

            // If all areas scanned, show completion message
            if (scannedCount >= 9) {
                document.getElementById('movement-text').textContent = '‚úì Room scan complete! Process images to generate 3D';
                hideAllArrows();
            }
        }

        function updateDirectionArrows() {
            hideAllArrows();

            if (!currentTargetArea) return;

            const [vertical, horizontal] = currentTargetArea.split('-');

            // Show arrows pointing to current target
            if (horizontal === 'left') {
                document.getElementById('arrow-left').classList.add('active');
            } else if (horizontal === 'right') {
                document.getElementById('arrow-right').classList.add('active');
            }

            if (vertical === 'top') {
                document.getElementById('arrow-up').classList.add('active');
            } else if (vertical === 'bottom') {
                document.getElementById('arrow-down').classList.add('active');
            }
        }

        function hideAllArrows() {
            document.querySelectorAll('.direction-arrow').forEach(arrow => {
                arrow.classList.remove('active');
            });
        }

        function updateMovementInstruction() {
            const textEl = document.getElementById('movement-text');
            const iconEl = document.querySelector('.movement-instruction .icon');

            if (!currentTargetArea) {
                textEl.textContent = 'Slowly pan camera across the room';
                return;
            }

            const instructions = {
                'top-left': { text: 'Pan UP and LEFT - capture ceiling corner', icon: '‚ÜñÔ∏è' },
                'top-center': { text: 'Tilt UP - capture ceiling and upper walls', icon: '‚¨ÜÔ∏è' },
                'top-right': { text: 'Pan UP and RIGHT - capture ceiling corner', icon: '‚ÜóÔ∏è' },
                'middle-left': { text: 'Pan LEFT - capture left wall', icon: '‚¨ÖÔ∏è' },
                'middle-center': { text: 'Hold steady - capture center of room', icon: 'üéØ' },
                'middle-right': { text: 'Pan RIGHT - capture right wall', icon: '‚û°Ô∏è' },
                'bottom-left': { text: 'Pan DOWN and LEFT - capture floor corner', icon: '‚ÜôÔ∏è' },
                'bottom-center': { text: 'Tilt DOWN - capture floor and furniture', icon: '‚¨áÔ∏è' },
                'bottom-right': { text: 'Pan DOWN and RIGHT - capture floor corner', icon: '‚ÜòÔ∏è' }
            };

            const instruction = instructions[currentTargetArea] || { text: 'Pan slowly', icon: 'üì∑' };
            textEl.textContent = instruction.text;
            iconEl.textContent = instruction.icon;
        }

        function markAreaCaptured(area) {
            if (targetAreasCovered[area] !== undefined) {
                targetAreasCovered[area] = 100;

                // Move to next area in sequence
                scanSequenceIndex++;
                if (scanSequenceIndex < scanSequence.length) {
                    currentTargetArea = scanSequence[scanSequenceIndex];
                } else {
                    currentTargetArea = null;
                }

                updateCameraGuide();
            }
        }

        function estimateCurrentArea(frameAnalysis) {
            // Estimate which area of the room the camera is pointing at
            // based on what's visible in the frame
            if (!frameAnalysis) return 'middle-center';

            const { boundaries, guidance } = frameAnalysis;

            // Simple heuristic based on floor/ceiling visibility
            let vertical = 'middle';
            let horizontal = 'center';

            if (guidance) {
                if (guidance.coverage.floor > 60) vertical = 'bottom';
                else if (guidance.coverage.ceiling > 60) vertical = 'top';

                if (guidance.coverage.wall_left > 60) horizontal = 'left';
                else if (guidance.coverage.wall_right > 60) horizontal = 'right';
            }

            return `${vertical}-${horizontal}`;
        }

        function updateCameraGuideFromAnalysis(analysisData) {
            if (!cameraGuideActive) return;

            // Estimate which area we're looking at
            const estimatedArea = estimateCurrentArea(analysisData);

            // Increment coverage for this area
            if (targetAreasCovered[estimatedArea] !== undefined) {
                targetAreasCovered[estimatedArea] = Math.min(100,
                    targetAreasCovered[estimatedArea] + 10);
            }

            // If current target is covered, advance
            if (targetAreasCovered[currentTargetArea] >= 100) {
                scanSequenceIndex++;
                if (scanSequenceIndex < scanSequence.length) {
                    currentTargetArea = scanSequence[scanSequenceIndex];
                } else {
                    currentTargetArea = null;
                }
            }

            updateCameraGuide();
        }

        // ============================================

        async function analyzeCurrentFrame() {
            if (!cameraStream || scanMode !== 'guided') return;

            const video = document.getElementById('camera-video');
            const canvas = document.getElementById('capture-canvas');

            if (!video.videoWidth) return;

            // Capture current frame
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);

            const imageData = canvas.toDataURL('image/jpeg', 0.5);  // Lower quality for speed

            try {
                const response = await fetch('/room/analyze-frame', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: imageData.split(',')[1] })
                });

                const data = await response.json();
                if (data.status === 'ok') {
                    updateGuidedOverlay(data);
                    drawBoundaries(data.boundaries, data.image_size);
                    lastGuidance = data;

                    // Update camera movement guide
                    updateCameraGuideFromAnalysis(data);

                    // Auto-capture logic
                    if (autoCapture && data.guidance.ready_to_scan) {
                        maybeAutoCapture(data);
                    }
                }
            } catch (err) {
                console.error('Frame analysis error:', err);
            }
        }

        function updateGuidedOverlay(data) {
            const guidance = data.guidance;

            // Update guidance text
            document.getElementById('guidance-text').textContent = guidance.suggestion;

            // Update coverage bars
            updateCoverageItem('cov-floor', guidance.coverage.floor);
            updateCoverageItem('cov-ceiling', guidance.coverage.ceiling);
            updateCoverageItem('cov-wall-left', guidance.coverage.wall_left);
            updateCoverageItem('cov-wall-right', guidance.coverage.wall_right);
            updateCoverageItem('cov-corners', guidance.coverage.corners);

            // Update quality ring
            const qualityPct = Math.round(guidance.quality_score * 100);
            const qualityRing = document.getElementById('quality-ring');
            qualityRing.textContent = `${qualityPct}%`;
            qualityRing.className = 'quality-ring ' +
                (qualityPct >= 60 ? 'high' : qualityPct >= 40 ? 'medium' : 'low');
        }

        function updateCoverageItem(id, value) {
            const el = document.getElementById(id);
            const pct = Math.round(value * 100);
            el.textContent = `${pct}%`;
            el.className = 'value ' + (pct >= 80 ? 'great' : pct >= 50 ? 'good' : '');
        }

        function drawBoundaries(boundaries, imageSize) {
            const canvas = document.getElementById('boundary-canvas');
            const video = document.getElementById('camera-video');

            // Match canvas to video display size
            const rect = video.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!boundaries || boundaries.length === 0) return;

            // Scale factors
            const scaleX = canvas.width / imageSize.width;
            const scaleY = canvas.height / imageSize.height;

            // Colors for different boundary types
            const colors = {
                floor: '#4ade80',     // Green
                ceiling: '#60a5fa',   // Blue
                wall_left: '#f472b6', // Pink
                wall_right: '#fb923c',// Orange
                corner: '#a78bfa'     // Purple
            };

            ctx.lineWidth = 3;
            ctx.lineCap = 'round';

            for (const boundary of boundaries) {
                const [x1, y1, x2, y2] = boundary.line;
                const color = colors[boundary.type] || '#888';

                ctx.strokeStyle = color;
                ctx.globalAlpha = Math.min(boundary.confidence + 0.3, 1.0);

                ctx.beginPath();
                ctx.moveTo(x1 * scaleX, y1 * scaleY);
                ctx.lineTo(x2 * scaleX, y2 * scaleY);
                ctx.stroke();

                // Draw label
                ctx.globalAlpha = 1.0;
                ctx.fillStyle = color;
                ctx.font = '10px sans-serif';
                ctx.fillText(boundary.type, (x1 + x2) / 2 * scaleX, (y1 + y2) / 2 * scaleY - 5);
            }

            ctx.globalAlpha = 1.0;
        }

        function clearBoundaryCanvas() {
            const canvas = document.getElementById('boundary-canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function toggleAutoCapture() {
            autoCapture = !autoCapture;
            const btn = document.getElementById('auto-capture-btn');
            btn.innerHTML = `<span>ü§ñ</span> Auto-Capture: ${autoCapture ? 'ON' : 'OFF'}`;
            btn.classList.toggle('btn-primary', autoCapture);
            btn.classList.toggle('btn-secondary', !autoCapture);
        }

        function maybeAutoCapture(data) {
            const now = Date.now();

            // Don't capture more than once every 2 seconds
            if (now - lastAutoCapture < 2000) return;

            // Check if this is a new view we haven't captured
            const currentView = getCurrentViewSignature(data);
            if (capturedViews.has(currentView)) return;

            // Only auto-capture high quality frames
            if (data.guidance.quality_score < 0.5) return;

            // Capture!
            lastAutoCapture = now;
            capturedViews.add(currentView);

            // Show capture animation
            const indicator = document.getElementById('auto-capture-indicator');
            indicator.style.display = 'block';
            setTimeout(() => indicator.style.display = 'none', 500);

            capturePhoto();

            // Update total coverage
            for (const key in data.guidance.coverage) {
                totalCoverage[key] = Math.max(totalCoverage[key], data.guidance.coverage[key]);
            }
        }

        function getCurrentViewSignature(data) {
            // Create a signature based on which boundaries are detected
            const types = data.boundaries.map(b => b.type).sort().join(',');
            const quality = Math.round(data.guidance.quality_score * 10);
            return `${types}-q${quality}`;
        }

        // Camera functions
        async function startCamera() {
            const video = document.getElementById('camera-video');
            const permission = document.getElementById('camera-permission');

            // Check if OAK-D camera is selected
            if (isOakdCamera(selectedCameraId)) {
                await startOakdCamera();
                return;
            }

            // Standard browser camera
            try {
                // Build video constraints based on selected camera
                let videoConstraints = {
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                };

                if (selectedCameraId) {
                    // Use specific camera by ID
                    videoConstraints.deviceId = { exact: selectedCameraId };
                } else {
                    // Fallback: try environment-facing camera (mobile) or any available
                    videoConstraints.facingMode = 'environment';
                }

                console.log('Starting camera with constraints:', videoConstraints);

                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: videoConstraints
                });

                video.srcObject = cameraStream;
                permission.classList.add('hidden');

                // Update camera select to show which camera is actually being used
                const tracks = cameraStream.getVideoTracks();
                if (tracks.length > 0) {
                    const settings = tracks[0].getSettings();
                    const label = tracks[0].label;
                    console.log('Camera started:', label, settings);
                }
                document.getElementById('capture-btn').disabled = false;
                document.getElementById('toggle-camera-btn').innerHTML = '<span>üé•</span> Stop Camera';
                document.getElementById('toggle-camera-btn').classList.remove('btn-secondary');
                document.getElementById('toggle-camera-btn').classList.add('btn-danger');

                // Start guided analysis if in guided mode
                if (scanMode === 'guided') {
                    startGuidedAnalysis();
                }

                // Activate camera guide for guided/fullauto modes
                if (scanMode === 'guided' || scanMode === 'fullauto') {
                    activateCameraGuide();
                }

            } catch (err) {
                console.error('Camera error:', err);
                document.getElementById('camera-permission').classList.remove('hidden');

                // Provide helpful message based on error type
                let errorTitle = 'Camera access denied or unavailable';
                let errorHelp = '';

                if (err.name === 'NotFoundError' || err.message.includes('not found')) {
                    errorTitle = 'No camera detected';
                    errorHelp = 'This device does not have a camera, or it is in use by another application.';
                } else if (err.name === 'NotAllowedError') {
                    errorTitle = 'Camera permission denied';
                    errorHelp = 'Please allow camera access in your browser settings.';
                }

                document.getElementById('camera-permission').innerHTML = `
                    <p>${errorTitle}</p>
                    <p style="font-size:0.8rem;color:#94a3b8;margin:0.5rem 0;">${errorHelp}</p>
                    <p style="font-size:0.8rem;color:#e94560;">${err.message}</p>
                    <div style="display:flex;gap:0.5rem;justify-content:center;margin-top:1rem;">
                        <button class="btn btn-secondary" onclick="startCamera()">Try Again</button>
                        <button class="btn btn-primary" onclick="document.getElementById('file-input').click()">Upload Image</button>
                    </div>
                `;
            }
        }

        // OAK-D specific camera functions
        async function startOakdCamera() {
            const video = document.getElementById('camera-video');
            const permission = document.getElementById('camera-permission');

            try {
                // Start OAK-D via server
                const startResponse = await fetch('/oakd/start', { method: 'POST' });
                const startData = await startResponse.json();

                if (startData.error || !startData.running) {
                    throw new Error(startData.error || 'Failed to start OAK-D');
                }

                oakdRunning = true;
                permission.classList.add('hidden');

                // Create a canvas to display OAK-D frames
                const canvas = document.createElement('canvas');
                canvas.id = 'oakd-canvas';
                canvas.width = 1280;
                canvas.height = 720;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.objectFit = 'contain';

                // Hide video, show canvas
                video.style.display = 'none';
                video.parentElement.appendChild(canvas);

                // Show depth view toggle
                showDepthViewToggle();

                // Start frame capture loop
                oakdCaptureInterval = setInterval(updateOakdFrame, 100);  // 10 FPS

                document.getElementById('capture-btn').disabled = false;
                document.getElementById('toggle-camera-btn').innerHTML = '<span>üé•</span> Stop OAK-D';
                document.getElementById('toggle-camera-btn').classList.remove('btn-secondary');
                document.getElementById('toggle-camera-btn').classList.add('btn-danger');

                console.log('OAK-D camera started');

                // Start guided analysis if in guided mode
                if (scanMode === 'guided') {
                    startGuidedAnalysis();
                }

            } catch (err) {
                console.error('OAK-D error:', err);
                permission.classList.remove('hidden');
                permission.innerHTML = `
                    <p>OAK-D Camera Error</p>
                    <p style="font-size:0.8rem;color:#94a3b8;">Could not start depth camera</p>
                    <p style="font-size:0.8rem;color:#e94560;">${err.message}</p>
                    <div style="display:flex;gap:0.5rem;justify-content:center;margin-top:1rem;">
                        <button class="btn btn-secondary" onclick="startCamera()">Try Again</button>
                        <button class="btn btn-primary" onclick="document.getElementById('file-input').click()">Upload Image</button>
                    </div>
                `;
            }
        }

        let showDepthView = false;
        let lastOakdFrame = null;

        function showDepthViewToggle() {
            // Add depth view toggle button if not exists
            if (!document.getElementById('depth-toggle-btn')) {
                const controls = document.querySelector('.camera-controls');
                const btn = document.createElement('button');
                btn.id = 'depth-toggle-btn';
                btn.className = 'btn btn-secondary';
                btn.innerHTML = '<span>üîµ</span> Show Depth';
                btn.onclick = toggleDepthView;
                controls.appendChild(btn);
            }
        }

        function hideDepthViewToggle() {
            const btn = document.getElementById('depth-toggle-btn');
            if (btn) btn.remove();
        }

        function toggleDepthView() {
            showDepthView = !showDepthView;
            const btn = document.getElementById('depth-toggle-btn');
            if (btn) {
                btn.innerHTML = showDepthView ? '<span>üåà</span> Show RGB' : '<span>üîµ</span> Show Depth';
                btn.classList.toggle('btn-primary', showDepthView);
                btn.classList.toggle('btn-secondary', !showDepthView);
            }
        }

        async function updateOakdFrame() {
            if (!oakdRunning) return;

            try {
                const response = await fetch('/oakd/capture?include_depth=true');
                const data = await response.json();

                if (data.error) {
                    console.warn('OAK-D capture error:', data.error);
                    return;
                }

                lastOakdFrame = data;

                const canvas = document.getElementById('oakd-canvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                const img = new Image();

                // Show RGB or depth based on toggle
                const imageData = showDepthView && data.depth ? data.depth : data.rgb;
                const mimeType = showDepthView && data.depth ? data.depth_mime : data.rgb_mime;

                if (imageData) {
                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                    };
                    img.src = `data:${mimeType};base64,${imageData}`;
                }

            } catch (err) {
                console.error('OAK-D frame update error:', err);
            }
        }

        function stopOakdCamera() {
            if (oakdCaptureInterval) {
                clearInterval(oakdCaptureInterval);
                oakdCaptureInterval = null;
            }

            // Stop OAK-D via server
            fetch('/oakd/stop', { method: 'POST' }).catch(err => console.warn('OAK-D stop error:', err));

            oakdRunning = false;
            lastOakdFrame = null;

            // Remove canvas, show video
            const canvas = document.getElementById('oakd-canvas');
            if (canvas) canvas.remove();

            const video = document.getElementById('camera-video');
            video.style.display = '';

            hideDepthViewToggle();

            console.log('OAK-D camera stopped');
        }

        function stopCamera() {
            // Stop OAK-D if running
            if (oakdRunning) {
                stopOakdCamera();
            }

            // Stop guided analysis
            stopGuidedAnalysis();
            clearBoundaryCanvas();

            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            document.getElementById('camera-video').srcObject = null;
            document.getElementById('capture-btn').disabled = true;
            document.getElementById('toggle-camera-btn').innerHTML = '<span>üé•</span> Start Camera';
            document.getElementById('toggle-camera-btn').classList.add('btn-secondary');
            document.getElementById('toggle-camera-btn').classList.remove('btn-danger');
        }

        function toggleCamera() {
            if (cameraStream) {
                stopCamera();
            } else {
                startCamera();
            }
        }

        function capturePhoto() {
            // Handle OAK-D capture
            if (oakdRunning && lastOakdFrame && lastOakdFrame.rgb) {
                const imageData = `data:${lastOakdFrame.rgb_mime};base64,${lastOakdFrame.rgb}`;
                addCapturedImage(imageData);

                // Also save depth if available (for 3D reconstruction)
                if (lastOakdFrame.depth) {
                    // Store depth data associated with this capture
                    const depthData = `data:${lastOakdFrame.depth_mime};base64,${lastOakdFrame.depth}`;
                    // Attach depth to the last captured image metadata
                    if (capturedImages.length > 0) {
                        // Store as metadata (for future use in 3D reconstruction)
                        console.log('Depth data captured alongside RGB');
                    }
                }
                return;
            }

            // Standard browser camera capture
            const video = document.getElementById('camera-video');
            const canvas = document.getElementById('capture-canvas');

            if (!video.srcObject) {
                alert('Camera not started');
                return;
            }

            // Set canvas size to video size
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            // Draw video frame to canvas
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);

            // Get image data as base64
            const imageData = canvas.toDataURL('image/jpeg', 0.9);

            // Add to captured images
            addCapturedImage(imageData);
        }

        function addCapturedImage(imageData) {
            capturedImages.push(imageData);
            updateImagePreview();
            updateButtons();
        }

        function removeImage(index) {
            capturedImages.splice(index, 1);
            updateImagePreview();
            updateButtons();
        }

        function clearImages() {
            capturedImages = [];
            updateImagePreview();
            updateButtons();
        }

        function updateImagePreview() {
            const container = document.getElementById('captured-images');
            const countEl = document.getElementById('image-count');

            countEl.textContent = `${capturedImages.length} image${capturedImages.length !== 1 ? 's' : ''}`;

            if (capturedImages.length === 0) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = capturedImages.map((img, idx) => `
                <div class="captured-image">
                    <img src="${img}" alt="Captured ${idx + 1}">
                    <button class="remove-btn" onclick="removeImage(${idx})">√ó</button>
                    <span class="image-number">${idx + 1}</span>
                </div>
            `).join('');
        }

        function updateButtons() {
            const hasImages = capturedImages.length > 0;
            document.getElementById('scan-btn').disabled = !hasImages;
            document.getElementById('clear-btn').disabled = !hasImages;
        }

        // File upload
        function handleFileUpload(event) {
            const files = event.target.files;
            for (const file of files) {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        addCapturedImage(e.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            }
            event.target.value = '';
        }

        // Drag and drop
        const uploadArea = document.getElementById('upload-area');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');

            const files = e.dataTransfer.files;
            for (const file of files) {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        addCapturedImage(ev.target.result);
                    };
                    reader.readAsDataURL(file);
                }
            }
        });

        // Scanning
        async function startScan() {
            if (capturedImages.length === 0) {
                alert('Please capture or upload at least one image');
                return;
            }

            const statusEl = document.getElementById('scan-status');
            const statusText = document.getElementById('status-text');
            const progressFill = document.getElementById('progress-fill');

            statusEl.classList.remove('hidden', 'success', 'error');
            statusEl.classList.add('processing');
            statusText.textContent = 'Processing images...';
            progressFill.style.width = '10%';

            try {
                // Prepare image data
                const images = capturedImages.map(img => img.split(',')[1]); // Remove data:image/...;base64, prefix

                progressFill.style.width = '30%';
                statusText.textContent = 'Analyzing room structure...';

                const response = await fetch('/room/scan', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        images: images,
                        room_scale: 10.0
                    })
                });

                progressFill.style.width = '70%';
                statusText.textContent = 'Generating 3D assets...';

                const data = await response.json();

                progressFill.style.width = '100%';

                if (data.error) {
                    throw new Error(data.error);
                }

                lastScanResult = data.result;
                statusEl.classList.remove('processing');
                statusEl.classList.add('success');
                statusText.textContent = `Scan complete! Generated ${lastScanResult.generated_assets?.length || 0} assets`;

                displayResults(lastScanResult);
                loadScanHistory();

            } catch (err) {
                statusEl.classList.remove('processing');
                statusEl.classList.add('error');
                statusText.textContent = `Error: ${err.message}`;
                console.error('Scan error:', err);
            }
        }

        function displayResults(result) {
            if (!result) return;

            // Stats
            document.getElementById('stat-objects').textContent = result.detected_objects?.length || 0;
            document.getElementById('stat-assets').textContent = result.generated_assets?.length || 0;
            document.getElementById('stat-images').textContent = result.images_processed || 0;
            document.getElementById('stat-time').textContent = `${(result.processing_time_ms || 0).toFixed(0)}ms`;

            // Assets list
            const assetList = document.getElementById('asset-list');
            const assets = result.generated_assets || [];

            if (assets.length === 0) {
                assetList.innerHTML = '<p style="color:#888;text-align:center;padding:1rem;">No assets detected</p>';
            } else {
                assetList.innerHTML = assets.map(asset => {
                    const colorHex = (asset.color || 0x808080).toString(16).padStart(6, '0');
                    return `
                        <div class="asset-item">
                            <div class="asset-type">
                                <div class="asset-color" style="background:#${colorHex}"></div>
                                <span>${asset.asset_type}</span>
                            </div>
                            <span class="asset-info">
                                ${asset.position?.x?.toFixed(1) || 0}, ${asset.position?.y?.toFixed(1) || 0}, ${asset.position?.z?.toFixed(1) || 0}
                            </span>
                        </div>
                    `;
                }).join('');
            }

            // Room dimensions
            const roomDims = result.room_dimensions;
            if (roomDims) {
                document.getElementById('room-dimensions').innerHTML = `
                    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:1rem;text-align:center;">
                        <div>
                            <div style="font-size:1.2rem;color:#4ade80;">${roomDims.width?.toFixed(1) || '-'}m</div>
                            <div style="font-size:0.75rem;color:#888;">Width</div>
                        </div>
                        <div>
                            <div style="font-size:1.2rem;color:#4ade80;">${roomDims.height?.toFixed(1) || '-'}m</div>
                            <div style="font-size:0.75rem;color:#888;">Height</div>
                        </div>
                        <div>
                            <div style="font-size:1.2rem;color:#4ade80;">${roomDims.depth?.toFixed(1) || '-'}m</div>
                            <div style="font-size:0.75rem;color:#888;">Depth</div>
                        </div>
                    </div>
                `;
            }

            // Enable export buttons
            document.getElementById('export-json-btn').disabled = false;
            document.getElementById('load-sim-btn').disabled = false;
        }

        function exportJSON() {
            if (!lastScanResult) return;

            const blob = new Blob([JSON.stringify(lastScanResult, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `room_scan_${lastScanResult.scan_id || 'export'}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        async function loadInSimulator() {
            // Gather scan data
            const scanData = {
                dimensions: {
                    width: parseFloat(document.getElementById('room-width')?.textContent) || 5.0,
                    height: parseFloat(document.getElementById('room-height')?.textContent) || 3.0,
                    depth: parseFloat(document.getElementById('room-depth')?.textContent) || 5.0
                },
                room_type: "living_room",  // Could be detected from objects
                objects: lastScanResult?.detected_objects?.map(obj => ({
                    type: obj.label || obj.type || "unknown",
                    position: obj.position || { x: 2, y: 2, z: 0 },
                    confidence: obj.confidence || 0.5
                })) || [],
                coverage: { ...roomCoverage },
                captured_images: capturedImages.length,
                scan_complete: scanComplete
            };

            addLog('Sending room to 3D Game simulator...');

            try {
                // Try to send to the 3D game server
                const response = await fetch('http://localhost:8083/api/load_scanned_room', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(scanData)
                });

                if (response.ok) {
                    const result = await response.json();
                    addLog(`Room loaded in simulator: ${result.level_id}`);

                    // Open the 3D game in a new tab
                    window.open('http://localhost:8083', '_blank');
                } else {
                    const error = await response.text();
                    addLog(`Simulator error: ${error}`, true);

                    // Fallback: store in localStorage and open HomeScan
                    localStorage.setItem('room_scan_assets', JSON.stringify(lastScanResult || scanData));
                    window.open('/homescan?load=latest', '_blank');
                }
            } catch (err) {
                // Server not running - use fallback
                addLog('3D Game server not running. Using HomeScan fallback...', true);
                localStorage.setItem('room_scan_assets', JSON.stringify(lastScanResult || scanData));
                window.open('/homescan?load=latest', '_blank');
            }
        }

        async function loadScanHistory() {
            try {
                const response = await fetch('/room/scans');
                const data = await response.json();

                const historyList = document.getElementById('scan-history-list');
                const scans = data.scans || [];

                if (scans.length === 0) {
                    historyList.innerHTML = '<p style="color:#666;font-size:0.85rem;">No previous scans</p>';
                    return;
                }

                historyList.innerHTML = scans.slice(0, 5).map(scan => `
                    <div class="scan-history-item" onclick="loadScan('${scan.scan_id}')">
                        <span>${scan.scan_id}</span>
                        <span class="scan-time">${scan.objects || 0} objects</span>
                    </div>
                `).join('');

            } catch (err) {
                console.error('Error loading scan history:', err);
            }
        }

        async function loadScan(scanId) {
            try {
                const response = await fetch(`/room/scan/${scanId}`);
                const data = await response.json();

                if (data.result) {
                    lastScanResult = data.result;
                    displayResults(lastScanResult);
                }
            } catch (err) {
                console.error('Error loading scan:', err);
            }
        }

        // =========================================
        // Three.js Room Preview Functions
        // =========================================

        function initThreeJSPreview() {
            if (threeScene) return; // Already initialized

            const canvas = document.getElementById('room-preview-canvas');
            const container = canvas.parentElement;

            // Scene
            threeScene = new THREE.Scene();
            threeScene.background = new THREE.Color(0x0a0a1a);

            // Camera
            const aspect = container.clientWidth / container.clientHeight;
            threeCamera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
            threeCamera.position.set(8, 6, 8);
            threeCamera.lookAt(0, 0, 0);

            // Renderer
            threeRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            threeRenderer.setSize(container.clientWidth, container.clientHeight);
            threeRenderer.setPixelRatio(window.devicePixelRatio);

            // Controls
            threeControls = new THREE.OrbitControls(threeCamera, threeRenderer.domElement);
            threeControls.enableDamping = true;
            threeControls.dampingFactor = 0.05;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            threeScene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            threeScene.add(directionalLight);

            // Grid helper
            const gridHelper = new THREE.GridHelper(10, 10, 0x2a2a4a, 0x1a1a3a);
            threeScene.add(gridHelper);

            // Room wireframe box (default 5x3x5 meters)
            createRoomBox(5, 3, 5);

            // Camera marker (represents capture position)
            createCameraMarker();

            // Start animation loop
            animateThreeJS();

            // Handle resize
            window.addEventListener('resize', onThreeResize);

            addLog('3D preview initialized');
        }

        function createRoomBox(width, height, depth) {
            if (roomBox) {
                threeScene.remove(roomBox);
            }

            // Create wireframe room
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const edges = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ color: 0x4ade80, opacity: 0.5, transparent: true });
            roomBox = new THREE.LineSegments(edges, material);
            roomBox.position.y = height / 2;
            threeScene.add(roomBox);

            // Add floor plane
            const floorGeometry = new THREE.PlaneGeometry(width, depth);
            const floorMaterial = new THREE.MeshBasicMaterial({
                color: 0x1a1a3a,
                side: THREE.DoubleSide,
                opacity: 0.3,
                transparent: true
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0.01;
            threeScene.add(floor);
        }

        function createCameraMarker() {
            // Camera frustum visualization
            const coneGeometry = new THREE.ConeGeometry(0.3, 0.5, 4);
            const coneMaterial = new THREE.MeshBasicMaterial({ color: 0xe94560 });
            cameraMarker = new THREE.Mesh(coneGeometry, coneMaterial);
            cameraMarker.rotation.x = Math.PI / 2;
            cameraMarker.position.set(0, 1.5, 4);
            threeScene.add(cameraMarker);
        }

        function animateThreeJS() {
            if (!threeRenderer) return;
            requestAnimationFrame(animateThreeJS);
            threeControls.update();
            threeRenderer.render(threeScene, threeCamera);
        }

        function onThreeResize() {
            if (!threeRenderer) return;
            const container = document.getElementById('room-preview-canvas').parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;
            threeCamera.aspect = width / height;
            threeCamera.updateProjectionMatrix();
            threeRenderer.setSize(width, height);
        }

        function addAssetToPreview(asset) {
            if (!threeScene) return;

            // Create simple box representation of asset
            const size = asset.size || { width: 0.5, height: 0.5, depth: 0.5 };
            const geometry = new THREE.BoxGeometry(
                size.width || 0.5,
                size.height || 0.5,
                size.depth || 0.5
            );

            const color = asset.color || 0x60a5fa;
            const material = new THREE.MeshPhongMaterial({
                color: color,
                opacity: 0.8,
                transparent: true
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(
                asset.position?.x || 0,
                asset.position?.y || 0.5,
                asset.position?.z || 0
            );

            threeScene.add(mesh);
            assetMeshes.push(mesh);

            // Add label sprite
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#4ade80';
            ctx.font = '14px sans-serif';
            ctx.fillText(asset.asset_type || 'Object', 4, 20);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(mesh.position);
            sprite.position.y += (size.height || 0.5) / 2 + 0.3;
            sprite.scale.set(1, 0.25, 1);
            threeScene.add(sprite);
            assetMeshes.push(sprite);
        }

        function addCaptureMarkerToPreview(position, direction) {
            if (!threeScene) return;

            // Small sphere at capture position
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0x4ade80 });
            const marker = new THREE.Mesh(geometry, material);
            marker.position.set(position.x, position.y, position.z);
            threeScene.add(marker);
            captureMarkers.push(marker);

            // Direction arrow
            const dir = new THREE.Vector3(direction.x, direction.y, direction.z).normalize();
            const arrowHelper = new THREE.ArrowHelper(dir, marker.position, 0.5, 0x4ade80);
            threeScene.add(arrowHelper);
            captureMarkers.push(arrowHelper);
        }

        function updateCameraMarkerPosition(areaName) {
            if (!cameraMarker) return;

            // Map area names to positions
            const positions = {
                'front-center': { x: 0, z: 4 },
                'front-left': { x: -2, z: 4 },
                'front-right': { x: 2, z: 4 },
                'center': { x: 0, z: 0 },
                'left': { x: -3, z: 0 },
                'right': { x: 3, z: 0 },
                'back-center': { x: 0, z: -4 },
                'back-left': { x: -2, z: -4 },
                'back-right': { x: 2, z: -4 }
            };

            const pos = positions[areaName] || positions['front-center'];
            cameraMarker.position.set(pos.x, 1.5, pos.z);

            document.getElementById('camera-position').textContent = `üì∑ Camera: ${areaName.replace('-', ' ')}`;
        }

        function resetRoomPreview() {
            // Clear all asset meshes
            assetMeshes.forEach(mesh => threeScene.remove(mesh));
            assetMeshes = [];

            // Clear capture markers
            captureMarkers.forEach(marker => threeScene.remove(marker));
            captureMarkers = [];

            // Reset coverage
            roomCoverage = {
                'back-left': 0, 'back-center': 0, 'back-right': 0,
                'left': 0, 'center': 0, 'right': 0,
                'front-left': 0, 'front-center': 0, 'front-right': 0
            };
            updateCoverageGrid();

            // Clear generated assets
            generatedAssets3D = [];
            capturePositions = [];

            // Clear log
            document.getElementById('capture-log').innerHTML = `
                <div class="log-entry">
                    <span class="log-time">${getTimeString()}</span>
                    <span class="log-msg">Preview reset</span>
                </div>
            `;

            addLog('Room preview reset');
        }

        function exportRoom3D() {
            // Simple JSON export for now (GLB would require GLTFExporter)
            const exportData = {
                room_dimensions: { width: 5, height: 3, depth: 5 },
                assets: generatedAssets3D,
                capture_positions: capturePositions,
                coverage: roomCoverage
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `room_3d_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);

            addLog('Room exported as JSON');
        }

        // =========================================
        // Full Auto Mode Functions
        // =========================================

        function toggleFullAuto() {
            console.log('toggleFullAuto called, current state:', fullAutoActive);
            if (fullAutoActive) {
                stopFullAuto();
            } else {
                startFullAuto();
            }
        }

        function startFullAuto() {
            if (!cameraStream && !oakdRunning) {
                addLog('Starting camera first...', true);
                startCamera().then(() => {
                    setTimeout(startFullAuto, 1000);
                });
                return;
            }

            fullAutoActive = true;
            lastFrameHash = null;
            stableFrameCount = 0;

            // Update UI
            const btn = document.getElementById('start-auto-btn');
            btn.innerHTML = '<span>‚è∏Ô∏è</span> Stop Scanning';
            btn.classList.remove('btn-primary');
            btn.classList.add('btn-danger');

            document.getElementById('status-dot').classList.add('active');
            document.getElementById('auto-status-text').textContent = 'Scanning...';
            document.getElementById('preview-status').textContent = 'Active';

            addLog('Full Auto scanning started');

            // Start the auto-capture loop
            fullAutoInterval = setInterval(fullAutoLoop, 500);
        }

        function stopFullAuto() {
            fullAutoActive = false;

            if (fullAutoInterval) {
                clearInterval(fullAutoInterval);
                fullAutoInterval = null;
            }

            // Update UI
            const btn = document.getElementById('start-auto-btn');
            btn.innerHTML = '<span>‚ñ∂Ô∏è</span> Start Scanning';
            btn.classList.add('btn-primary');
            btn.classList.remove('btn-danger');

            document.getElementById('status-dot').classList.remove('active', 'processing');
            document.getElementById('auto-status-text').textContent = 'Stopped';
            document.getElementById('preview-status').textContent = 'Paused';

            addLog('Full Auto scanning stopped');
        }

        async function fullAutoLoop() {
            if (!fullAutoActive) return;
            if (isProcessing) return; // Skip if still processing previous capture

            try {
                // Capture current frame
                let imageData = null;

                if (oakdRunning && lastOakdFrame && lastOakdFrame.rgb) {
                    imageData = `data:${lastOakdFrame.rgb_mime};base64,${lastOakdFrame.rgb}`;
                } else if (cameraStream) {
                    const video = document.getElementById('camera-video');
                    const canvas = document.getElementById('capture-canvas');
                    if (video.videoWidth > 0) {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(video, 0, 0);
                        imageData = canvas.toDataURL('image/jpeg', 0.8);
                    }
                }

                if (!imageData) return;

                // Time-based auto-capture for OAK-D (hash-based stability doesn't work well
                // with JPEG's variable encoding). Capture every ~3 seconds when scanning.
                stableFrameCount++;

                // Capture every 6 loop iterations (~3 seconds at 500ms interval)
                if (stableFrameCount >= 6) {
                    stableFrameCount = 0;

                    // Show capture animation
                    const indicator = document.getElementById('auto-capture-indicator');
                    indicator.style.display = 'block';
                    setTimeout(() => indicator.style.display = 'none', 500);

                    addLog('Stable frame detected, capturing...');

                    // Add to captured images
                    addCapturedImage(imageData);

                    // Immediately process this capture
                    await processCapture(imageData);
                }

            } catch (err) {
                console.error('Full auto loop error:', err);
                addLog('Error: ' + err.message, true);
            }
        }

        async function processCapture(imageData) {
            if (isProcessing) return;
            isProcessing = true;

            document.getElementById('status-dot').classList.add('processing');
            document.getElementById('status-dot').classList.remove('active');
            document.getElementById('auto-status-text').textContent = 'Processing...';

            try {
                const base64Data = imageData.split(',')[1];

                const response = await fetch('/room/scan', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        images: [base64Data],
                        room_scale: 10.0,
                        quick_mode: true  // Request faster processing for real-time
                    })
                });

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                const result = data.result;

                // Update 3D preview with detected assets
                if (result.generated_assets && result.generated_assets.length > 0) {
                    for (const asset of result.generated_assets) {
                        addAssetToPreview(asset);
                        generatedAssets3D.push(asset);
                    }
                    addLog(`Found ${result.generated_assets.length} objects`);
                }

                // Estimate capture area and update coverage
                const captureArea = estimateCaptureArea(result);
                updateCaptureArea(captureArea);

                // Add capture position marker
                const capturePos = {
                    x: (Math.random() - 0.5) * 4,
                    y: 1.5,
                    z: 3 + Math.random() * 2
                };
                capturePositions.push(capturePos);
                addCaptureMarkerToPreview(capturePos, { x: 0, y: 0, z: -1 });

                // Store frame with depth for 3D reconstruction
                if (oakdRunning && lastOakdFrame) {
                    capturedFrames.push({
                        rgb: lastOakdFrame.rgb,
                        depth: lastOakdFrame.depth,
                        position: capturePos,
                        area: captureArea,
                        timestamp: Date.now()
                    });
                }

                // Update results display
                displayResults(result);
                lastScanResult = result;

                addLog(`Processed: ${result.detected_objects?.length || 0} objects detected`);

                // Check if we have enough coverage to auto-stop
                if (fullAutoActive && checkCoverageComplete()) {
                    addLog('Room scan complete! Generating 3D reconstruction...');
                    stopFullAuto();
                    scanComplete = true;
                    await generate3DReconstruction();

                    // Enable Load in Simulator button
                    document.getElementById('load-sim-btn').disabled = false;
                    addLog('Ready to load in 3D Game simulator!');
                }

            } catch (err) {
                console.error('Process capture error:', err);
                addLog('Process error: ' + err.message, true);
            } finally {
                isProcessing = false;
                if (fullAutoActive) {
                    document.getElementById('status-dot').classList.remove('processing');
                    document.getElementById('status-dot').classList.add('active');
                    document.getElementById('auto-status-text').textContent = 'Scanning...';
                }
            }
        }

        function estimateCaptureArea(result) {
            // Simple heuristic based on detected objects and boundaries
            const areas = ['front-center', 'front-left', 'front-right', 'center', 'left', 'right', 'back-center', 'back-left', 'back-right'];

            // For now, pick area based on capture count (round-robin with some randomness)
            const captureCount = capturePositions.length;
            const baseIndex = captureCount % areas.length;

            // Add some variation
            const variation = Math.floor(Math.random() * 3) - 1;
            const index = Math.max(0, Math.min(areas.length - 1, baseIndex + variation));

            return areas[index];
        }

        function updateCaptureArea(areaName) {
            // Increase coverage for this area
            if (roomCoverage[areaName] !== undefined) {
                roomCoverage[areaName] = Math.min(1, roomCoverage[areaName] + 0.5);
            }

            updateCoverageGrid();
            updateCameraMarkerPosition(areaName);
        }

        function updateCoverageGrid() {
            const cells = document.querySelectorAll('.coverage-cell');
            cells.forEach(cell => {
                const area = cell.getAttribute('data-area');
                const coverage = roomCoverage[area] || 0;

                cell.classList.remove('captured', 'partial');
                if (coverage >= 0.8) {
                    cell.classList.add('captured');
                } else if (coverage >= 0.3) {
                    cell.classList.add('partial');
                }
            });
        }

        function checkCoverageComplete() {
            // Check if we have enough room coverage (7+ zones with >= 0.5 coverage)
            const coverageValues = Object.values(roomCoverage);
            const capturedZones = coverageValues.filter(v => v >= 0.5).length;
            const totalCoverage = coverageValues.reduce((a, b) => a + b, 0) / coverageValues.length;

            // Also require minimum number of frames
            const minFrames = 6;
            const hasEnoughFrames = capturedFrames.length >= minFrames;

            // Complete when 7+ zones captured OR high average coverage with enough frames
            return (capturedZones >= 7 || totalCoverage >= 0.7) && hasEnoughFrames;
        }

        async function generate3DReconstruction() {
            addLog('Building 3D room model...');
            document.getElementById('auto-status-text').textContent = 'Building 3D Model...';

            try {
                // Update 3D preview status
                const statusText = document.getElementById('auto-status-text');
                if (statusText) statusText.textContent = 'Generating 3D...';

                // Create textured room from captured images
                await createTexturedRoom();

                // Create panoramic view
                await createPanoramicView();

                // Update view mode buttons
                showViewModeButtons();

                addLog('3D reconstruction complete!');
                document.getElementById('auto-status-text').textContent = 'Scan Complete!';

                // Show completion notification
                showCompletionNotification();

            } catch (err) {
                console.error('3D reconstruction error:', err);
                addLog('Reconstruction error: ' + err.message, true);
            }
        }

        async function createTexturedRoom() {
            if (!threeScene || capturedFrames.length === 0) return;

            // Get room dimensions from last scan result
            const dims = lastScanResult?.room_dimensions || { width: 5, height: 3, depth: 5 };
            const width = dims.width || 5;
            const height = dims.height || 3;
            const depth = dims.depth || 5;

            // Remove old room box
            if (roomBox) {
                threeScene.remove(roomBox);
            }

            // Create room geometry
            const roomGeom = new THREE.BoxGeometry(width, height, depth);

            // Load textures from captured frames for each wall
            const materials = [];
            const wallFrames = selectFramesForWalls();

            for (let i = 0; i < 6; i++) {
                const frame = wallFrames[i];
                if (frame && frame.rgb) {
                    try {
                        const texture = await loadTextureFromBase64(frame.rgb, frame.rgb_mime || 'image/jpeg');
                        materials.push(new THREE.MeshBasicMaterial({
                            map: texture,
                            side: THREE.BackSide
                        }));
                    } catch (e) {
                        materials.push(new THREE.MeshBasicMaterial({
                            color: 0x334155,
                            side: THREE.BackSide
                        }));
                    }
                } else {
                    materials.push(new THREE.MeshBasicMaterial({
                        color: 0x334155,
                        side: THREE.BackSide
                    }));
                }
            }

            reconstructionMesh = new THREE.Mesh(roomGeom, materials);
            reconstructionMesh.position.set(0, height / 2, 0);
            reconstructionMesh.visible = false;  // Start hidden, show when view mode selected
            threeScene.add(reconstructionMesh);

            addLog('Textured room created');
        }

        function selectFramesForWalls() {
            // Select best frames for each wall face: right, left, top, bottom, front, back
            const wallFrames = [null, null, null, null, null, null];

            // Map areas to wall indices
            const areaToWall = {
                'right': 0, 'left': 1,
                'back-center': 5, 'back-left': 5, 'back-right': 5,
                'front-center': 4, 'front-left': 4, 'front-right': 4,
                'center': 3  // floor
            };

            for (const frame of capturedFrames) {
                const wallIndex = areaToWall[frame.area];
                if (wallIndex !== undefined && !wallFrames[wallIndex]) {
                    wallFrames[wallIndex] = frame;
                }
            }

            // Fill remaining with any available frame
            const anyFrame = capturedFrames[0];
            for (let i = 0; i < 6; i++) {
                if (!wallFrames[i]) wallFrames[i] = anyFrame;
            }

            return wallFrames;
        }

        function loadTextureFromBase64(base64Data, mimeType) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const texture = new THREE.Texture(img);
                    texture.needsUpdate = true;
                    resolve(texture);
                };
                img.onerror = reject;
                img.src = `data:${mimeType};base64,${base64Data}`;
            });
        }

        async function createPanoramicView() {
            if (!threeScene || capturedFrames.length === 0) return;

            // Create a sphere with captured images stitched together
            const sphereGeom = new THREE.SphereGeometry(10, 32, 16);

            // For a simple panorama, use the most central frame
            const centerFrame = capturedFrames.find(f => f.area === 'center') || capturedFrames[0];

            if (centerFrame && centerFrame.rgb) {
                try {
                    const texture = await loadTextureFromBase64(centerFrame.rgb, 'image/jpeg');
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.repeat.x = -1;  // Flip for inside view

                    const sphereMat = new THREE.MeshBasicMaterial({
                        map: texture,
                        side: THREE.BackSide
                    });

                    panoramaTexture = new THREE.Mesh(sphereGeom, sphereMat);
                    panoramaTexture.position.set(0, 1.5, 0);
                    panoramaTexture.visible = false;
                    threeScene.add(panoramaTexture);

                    addLog('Panoramic view created');
                } catch (e) {
                    console.error('Panorama creation error:', e);
                }
            }
        }

        function showViewModeButtons() {
            // Add view mode toggle buttons to the 3D preview panel
            const roomPreviewPanel = document.getElementById('room-preview-panel');
            if (!roomPreviewPanel) return;

            // Check if buttons already exist
            if (document.getElementById('view-mode-btns')) return;

            const btnContainer = document.createElement('div');
            btnContainer.id = 'view-mode-btns';
            btnContainer.style.cssText = 'display:flex;gap:0.5rem;margin:1rem 0;flex-wrap:wrap;justify-content:center;';

            const modes = [
                { id: 'wireframe', label: 'üìê Wireframe', active: true },
                { id: 'textured', label: 'üè† Textured' },
                { id: 'panorama', label: 'üåê Panorama' },
                { id: 'depth', label: 'üìä Depth' }
            ];

            modes.forEach(mode => {
                const btn = document.createElement('button');
                btn.className = `view-mode-btn ${mode.active ? 'active' : ''}`;
                btn.textContent = mode.label;
                btn.style.cssText = 'padding:0.4rem 0.8rem;font-size:0.8rem;border-radius:6px;border:1px solid #334155;background:' + (mode.active ? '#4ade80' : '#1e293b') + ';color:' + (mode.active ? '#000' : '#e2e8f0') + ';cursor:pointer;transition:all 0.2s;';
                btn.onclick = () => setViewMode(mode.id);
                btnContainer.appendChild(btn);
            });

            // Insert after the coverage panel, before the controls
            const coveragePanel = roomPreviewPanel.querySelector('.coverage-3d-panel');
            const previewControls = roomPreviewPanel.querySelector('.preview-controls');
            if (coveragePanel && previewControls) {
                roomPreviewPanel.insertBefore(btnContainer, previewControls);
            } else if (coveragePanel) {
                coveragePanel.parentNode.insertBefore(btnContainer, coveragePanel.nextSibling);
            } else {
                roomPreviewPanel.appendChild(btnContainer);
            }
        }

        function setViewMode(mode) {
            currentViewMode = mode;

            // Update button styles
            document.querySelectorAll('.view-mode-btn').forEach(btn => {
                const isActive = btn.textContent.toLowerCase().includes(mode);
                btn.style.background = isActive ? '#4ade80' : '#1e293b';
                btn.style.color = isActive ? '#000' : '#e2e8f0';
            });

            // Update 3D scene visibility
            if (roomBox) roomBox.visible = (mode === 'wireframe');
            if (reconstructionMesh) reconstructionMesh.visible = (mode === 'textured');
            if (panoramaTexture) panoramaTexture.visible = (mode === 'panorama');

            // Show depth visualization
            if (mode === 'depth') {
                showDepthVisualization();
            }

            addLog(`View mode: ${mode}`);
        }

        function showDepthVisualization() {
            // Create depth point cloud from captured depth frames
            if (!threeScene || capturedFrames.length === 0) return;

            // Remove existing point cloud
            const existingCloud = threeScene.getObjectByName('depthCloud');
            if (existingCloud) threeScene.remove(existingCloud);

            // For now, show a simple depth-colored room
            if (roomBox) roomBox.visible = true;

            // Colorize based on depth - this is a simplified visualization
            // A full implementation would create actual point clouds from depth images
            addLog('Depth view active (simplified)');
        }

        function showCompletionNotification() {
            // Create a completion overlay
            const overlay = document.createElement('div');
            overlay.id = 'scan-complete-overlay';
            overlay.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
                border: 2px solid #4ade80;
                border-radius: 12px;
                padding: 2rem;
                z-index: 1000;
                text-align: center;
                box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            `;
            overlay.innerHTML = `
                <div style="font-size:3rem;margin-bottom:1rem;">‚úÖ</div>
                <h2 style="color:#4ade80;margin:0 0 1rem 0;">Room Scan Complete!</h2>
                <p style="color:#94a3b8;margin:0 0 1rem 0;">
                    Captured ${capturedFrames.length} frames<br>
                    Coverage: ${Math.round(Object.values(roomCoverage).reduce((a,b) => a+b, 0) / 9 * 100)}%
                </p>
                <div style="display:flex;gap:0.5rem;justify-content:center;flex-wrap:wrap;">
                    <button onclick="setViewMode('textured');this.parentNode.parentNode.remove();"
                            style="padding:0.5rem 1rem;background:#4ade80;color:#000;border:none;border-radius:6px;cursor:pointer;font-weight:bold;">
                        üè† View Textured Room
                    </button>
                    <button onclick="setViewMode('panorama');this.parentNode.parentNode.remove();"
                            style="padding:0.5rem 1rem;background:#3b82f6;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:bold;">
                        üåê View Panorama
                    </button>
                    <button onclick="this.parentNode.parentNode.remove();"
                            style="padding:0.5rem 1rem;background:#334155;color:#e2e8f0;border:none;border-radius:6px;cursor:pointer;">
                        Close
                    </button>
                </div>
            `;
            document.body.appendChild(overlay);

            // Auto-close after 10 seconds
            setTimeout(() => {
                if (document.getElementById('scan-complete-overlay')) {
                    document.getElementById('scan-complete-overlay').remove();
                }
            }, 10000);
        }

        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash;
        }

        function addLog(message, isError = false) {
            const logContainer = document.getElementById('capture-log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `
                <span class="log-time">${getTimeString()}</span>
                <span class="log-msg ${isError ? 'error' : ''}">${message}</span>
            `;
            logContainer.insertBefore(entry, logContainer.firstChild);

            // Keep only last 20 entries
            while (logContainer.children.length > 20) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        function getTimeString() {
            const now = new Date();
            return now.toLocaleTimeString('en-US', { hour12: false });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            loadScanHistory();

            // Add event listener for Start Scanning button (more reliable than onclick)
            const startAutoBtn = document.getElementById('start-auto-btn');
            if (startAutoBtn) {
                startAutoBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Start Scanning button clicked, fullAutoActive:', fullAutoActive);
                    toggleFullAuto();
                });
            }

            // Check if camera API is available and enumerate cameras
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                document.getElementById('camera-permission').classList.add('hidden');

                // Enumerate available cameras
                const cameras = await enumerateCameras();
                if (cameras.length === 0) {
                    document.getElementById('camera-permission').classList.remove('hidden');
                    document.getElementById('camera-permission').innerHTML = `
                        <p>No cameras detected</p>
                        <p style="font-size:0.8rem;color:#94a3b8;">Connect a USB camera and refresh, or use file upload</p>
                        <div style="display:flex;gap:0.5rem;justify-content:center;margin-top:1rem;">
                            <button class="btn btn-secondary" onclick="enumerateCameras()">Refresh Cameras</button>
                            <button class="btn btn-primary" onclick="document.getElementById('file-input').click()">Upload Image</button>
                        </div>
                    `;
                }
            } else {
                document.getElementById('camera-permission').classList.remove('hidden');
                document.getElementById('camera-permission').innerHTML = `
                    <p>Camera API not available</p>
                    <p style="font-size:0.8rem;color:#888;">Use file upload instead</p>
                    <button class="btn btn-primary" onclick="document.getElementById('file-input').click()">Upload Image</button>
                `;
            }
        });
    </script>
</body>
</html>
