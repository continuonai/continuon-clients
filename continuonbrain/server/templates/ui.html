<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CraigBot Control</title>
    <link rel="stylesheet" href="/static/ui.css">
</head>
<body class="ide-body">
    <div class="ide-shell">
        <header class="ide-topbar">
            <div class="brand">
                <div class="brand-mark">ü§ñ</div>
                <div>
                    <div class="brand-title">Continuon AI Agent Manager</div>
                    <div class="brand-subtitle">Default agent: HOPE (Gemma fallback)</div>
                </div>
            </div>
            <div class="top-status">
                <div class="chip" id="mode">Loading...</div>
                <div class="chip" id="recording">No</div>
                <div class="chip" id="motion">No</div>
                <div class="chip" id="model-stack-chip">Model stack: HOPE ‚Üí Gemini ‚Üí Gemma</div>
            </div>
        </header>
        <nav class="nav-links">
            <a class="nav-link" href="/ui">Home</a>
            <a class="nav-link" href="/control">Control</a>
            <a class="nav-link" href="/settings">Settings</a>
            <div class="view-toggle">
                <button id="owner-view-btn" class="active" onclick="window.setViewMode('owner')">Owner</button>
                <button id="research-view-btn" onclick="window.setViewMode('research')">Research</button>
            </div>
        </nav>

        <div class="ide-workspace">
            <aside class="ide-sidebar">
                <div class="sidebar-section">
                    <div class="sidebar-title">Command Deck</div>
                    <div class="command-grid">
                        <button id="manual-control-btn" class="command-btn primary" onclick="startManualControl(this)">üéÆ Manual Control</button>
                        <button class="command-btn" onclick="setMode('autonomous')">üöÄ Autonomous</button>
                        <button class="command-btn" onclick="setMode('sleep_learning')">üí§ Sleep Learning</button>
                        <button class="command-btn subtle" onclick="setMode('idle')">‚è∏Ô∏è Idle</button>
                    </div>
                </div>
                
                <div class="sidebar-footnote">Use the deck like an IDE command palette to swap modes quickly.</div>
            </aside>

            <main class="ide-main">
                <section class="panel owner-only">
                    <div class="panel-header">
                        <div>
                            <div class="panel-eyebrow">Live State</div>
                            <h2>Robot Health Overview</h2>
                            <p class="panel-subtitle">Visualize safety status, recording posture, and motion gates.</p>
                        </div>
                    </div>
                    <div class="status-deck">
                        <div class="status-card">
                            <div class="status-label">Robot Mode</div>
                            <div class="status-value" id="mode-card">mirrors mode badge</div>
                        </div>
                        <div class="status-card">
                            <div class="status-label">Recording</div>
                            <div class="status-value" id="recording-card">No</div>
                        </div>
                        <div class="status-card">
                            <div class="status-label">Motion Allowed</div>
                            <div class="status-value" id="motion-card">No</div>
                        </div>
                    </div>
                    <div class="agent-chip-row" id="agent-chip-row">
                        <!-- Agent status chips injected by JS -->
                    </div>
                </section>

                <section class="panel owner-only">
                    <div class="panel-header">
                        <div>
                            <div class="panel-eyebrow">Modes</div>
                            <h2>Robot & Training Modes</h2>
                            <p class="panel-subtitle">See available modes and which one is active.</p>
                        </div>
                    </div>
                    <div class="status-deck">
                        <div class="status-card">
                            <div class="status-label">Robot Modes</div>
                            <div class="mode-pills" id="mode-pill-container">
                                <!-- filled by JS -->
                            </div>
                        </div>
                        <div class="status-card">
                            <div class="status-label">Training Modes</div>
                            <div class="mode-pills" id="training-mode-container">
                                <span class="mode-pill">Local LoRA</span>
                                <span class="mode-pill">On-device fine-tune</span>
                                <span class="mode-pill">RLDS ingest</span>
                            </div>
                        </div>
                    </div>
                </section>

                <section class="panel owner-only">
                    <div class="panel-header">
                        <div>
                            <div class="panel-eyebrow">Task Library</div>
                            <h2>Autonomy Task Deck</h2>
                            <p class="panel-subtitle">Group tasks by intent, check eligibility markers, and hand off to the robot.</p>
                        </div>
                        <div class="selected-task-pill" id="current-task-pill">No task selected</div>
                    </div>
                    <div class="task-group-controls">
                        <div class="segmented-controls" id="task-group-segments"></div>
                        <input id="task-filter-input" class="input-compact" type="search" placeholder="Filter tasks..." oninput="window.filterTaskText(this.value)">
                    </div>
                    <div class="task-groups-accordion" id="task-groups">
                        <div class="status-item">
                            <span class="status-label">Loading tasks...</span>
                        </div>
                    </div>
                </section>

                <section class="panel owner-only">
                    <div class="panel-header">
                        <div>
                            <div class="panel-eyebrow">Skill Library</div>
                            <h2>Reusable Skills</h2>
                            <p class="panel-subtitle">Capability-driven skills shareable across robots; pin favorites for quick use.</p>
                        </div>
                        <div class="segmented-controls tight">
                            <input id="skill-filter-input" class="input-compact" type="search" placeholder="Filter skills..." oninput="window.filterSkillText(this.value)">
                            <button class="ghost" onclick="window.fetchSkillLibrary()">Refresh</button>
                        </div>
                    </div>
                    <div class="panel-subtitle mt-8" id="pinned-skill-pill">Pinned skill: none</div>
                    <div id="skill-groups" class="skill-grid">
                        <div class="status-item">
                            <span class="status-label">Loading skills...</span>
                        </div>
                    </div>
                </section>

                <section class="panel">
                    <div class="panel-header">
                        <div>
                            <div class="panel-eyebrow">Training & RLDS</div>
                            <h2>Training Controls</h2>
                            <p class="panel-subtitle">Kick off local training, inspect logs, and manage episodes.</p>
                        </div>
                        <div class="chip subtle">Mock-safe in UI</div>
                    </div>
                    <div class="command-grid">
                        <button class="command-btn primary" onclick="window.requestTraining()">üöÄ Run Training</button>
                        <button class="command-btn" onclick="window.viewTrainingLogs()">üìú View Logs</button>
                        <button class="command-btn" onclick="window.openEpisodeImports()">üì¶ Import Episodes</button>
                    </div>
                    <div class="panel-subtitle mt-8" id="training-status">Idle</div>
                </section>

                <section class="panel research-only">
                    <div class="panel-header">
                        <div>
                            <div class="panel-eyebrow">Neural Topology</div>
                            <h2>Brain Map</h2>
                            <p class="panel-subtitle">HOPE topology snapshot (mock visual placeholder).</p>
                        </div>
                    </div>
                    <div class="status-deck">
                        <div class="status-card">
                            <div class="status-label">Architecture</div>
                            <div class="status-value">HOPE-v1</div>
                        </div>
                        <div class="status-card">
                            <div class="status-label">Active Columns</div>
                            <div class="status-value">4</div>
                        </div>
                        <div class="status-card">
                            <div class="status-label">Global Status</div>
                            <div class="status-value">UNKNOWN</div>
                        </div>
                        <div class="status-card">
                            <div class="status-label">Lyapunov Energy</div>
                            <div class="status-value">0.00</div>
                        </div>
                    </div>
                </section>

                <section class="panel research-only">
                    <div class="panel-header">
                        <div>
                            <div class="panel-eyebrow">HOPE / CMS</div>
                            <h2>Loop Telemetry</h2>
                            <p class="panel-subtitle">Wave/particle balance and core loop health.</p>
                        </div>
                    </div>
                    <div class="loop-grid">
                        <div class="loop-card">
                            <div class="loop-title">Wave / Particle</div>
                            <div class="gauge-bar"><div class="gauge-fill" id="wave-meter"></div></div>
                            <div class="loop-meta" id="wave-value">--</div>
                        </div>
                        <div class="loop-card">
                            <div class="loop-title">HOPE Loops</div>
                            <div class="loop-meta" id="hope-fast">Fast: --</div>
                            <div class="loop-meta" id="hope-mid">Mid: --</div>
                            <div class="loop-meta" id="hope-slow">Slow: --</div>
                        </div>
                        <div class="loop-card">
                            <div class="loop-title">CMS Balance</div>
                            <div class="loop-meta" id="cms-ratio">--</div>
                            <div class="loop-meta" id="cms-buffer">Buffer: --</div>
                        </div>
                    </div>
                </section>

                <section class="panel research-only">
                    <div class="panel-header">
                        <div>
                            <div class="panel-eyebrow">Performance</div>
                            <h2>System Performance</h2>
                            <p class="panel-subtitle">Latency, gates, and health snapshots.</p>
                        </div>
                    </div>
                    <div class="status-deck">
                        <div class="status-card">
                            <div class="status-label">Motion Gate</div>
                            <div class="status-value" id="gate-allow">--</div>
                        </div>
                        <div class="status-card">
                            <div class="status-label">Recording Gate</div>
                            <div class="status-value" id="gate-record">--</div>
                        </div>
                        <div class="status-card">
                            <div class="status-label">Safety Head</div>
                            <div class="status-value" id="safety-head-path">loading...</div>
                        </div>
                    </div>
                </section>

                </section>

                <!-- Tabs for View Switcher -->
                <div class="tabs-container">
                    <button class="tab-btn active" data-tab="dashboard" onclick="switchHomeTab('dashboard')">üìä Dashboard</button>
                    <button class="tab-btn" data-tab="robot-view" onclick="switchHomeTab('robot-view')">ü§ñ Robot Layout</button>
                </div>

                <!-- Dashboard View (Sensors + Workspace) -->
                <div id="dashboard-panel" class="home-panel">
                    <section class="panel">
                        <div class="panel-header">
                            <div>
                                <div class="panel-eyebrow">Sensors</div>
                                <h2>Hardware Canvas</h2>
                                <p class="panel-subtitle">Auto-discovered sensors render into a visual rack.</p>
                            </div>
                        </div>
                        <div class="sensor-grid" id="hardware-status">
                            <div class="status-item">
                                <span class="status-label">Loading sensors...</span>
                            </div>
                        </div>
                    </section>

                    <section class="panel panel-spaced">
                <div class="panel-header">
                    <div>
                        <div class="panel-eyebrow">Workspace</div>
                        <h2>Editor Canvas</h2>
                        <p class="panel-subtitle">A visual staging area that mirrors robot readiness.</p>
                            </div>
                        </div>
                        <div class="canvas-grid">
                            <div class="canvas-card">
                                <div class="canvas-title">Mode Timeline</div>
                                <p class="canvas-text">Snapshot of the current behavior lane.</p>
                            </div>
                            <div class="canvas-card">
                                <div class="canvas-title">Safety Boundaries</div>
                                <p class="canvas-text">Motion gates active.</p>
                            </div>
                        </div>
                    </section>
                </div>

                <!-- Robot Layout View -->
                <div id="robot-view-panel" class="home-panel hidden">
                    <section class="panel">
                        <div class="panel-header">
                            <div>
                                <div class="panel-eyebrow">Visual Status</div>
                                <h2>System Health Map</h2>
                                <p class="panel-subtitle">Component-level health and connectivity status.</p>
                            </div>
                        </div>
                        
                        <div class="viz-wrap">
                            <!-- Visual Robot Representation -->
                            <div class="viz-base">
                                
                                <!-- Base -->
                                <div class="viz-base-card">
                                    <span class="viz-base-label">BASE / DRIVETRAIN</span>
                                    <span id="viz-base-status" class="viz-base-status">üü¢</span>
                                </div>
                                
                                <!-- Arm -->
                                <div class="viz-arm">
                                    <span class="viz-arm-label">ARM/GRIPPER</span>
                                    <span id="viz-arm-status" class="viz-arm-status">üü¢</span>
                                </div>

                                <!-- Head/Camera -->
                                <div class="viz-vision">
                                    <span class="viz-vision-label">VISION</span>
                                    <span id="viz-vision-status" class="viz-vision-status">üü¢</span>
                                </div>
                                
                                <!-- Core -->
                                <div class="viz-brain">
                                    <span class="viz-brain-label">BRAIN</span>
                                    <span id="viz-brain-status" class="viz-brain-status">üß†</span>
                                </div>
                            </div>
                            
                            <div class="viz-text">
                                <div class="status-item">
                                    <span class="status-label">Overall Safety Check</span>
                                    <span class="status-value status-good">PASSED</span>
                                </div>
                                <div class="status-item">
                                    <span class="status-label">Battery / Power</span>
                                    <span class="status-value">100% (Simulated)</span>
                                </div>
                                <div class="status-item">
                                    <span class="status-label">NPU Load</span>
                                    <span class="status-value">Low</span>
                                </div>
                            </div>
                        </div>
                    </section>
                </div>


                <section class="panel research-only">
                <div class="panel-header">
                    <div>
                            <div class="panel-eyebrow">Workspace</div>
                            <h2>Editor Canvas</h2>
                            <p class="panel-subtitle">A visual staging area that mirrors robot readiness.</p>
                    </div>
                </div>
                    <div class="canvas-grid">
                        <div class="canvas-card">
                            <div class="canvas-title">Mode Timeline</div>
                            <p class="canvas-text">Snapshot of the current behavior lane; switch to Manual Control for a live scene.</p>
                        </div>
                        <div class="canvas-card">
                            <div class="canvas-title">Safety Boundaries</div>
                            <p class="canvas-text">Motion gates, emergency stops, and recording toggles stay front and center in this editor skin.</p>
                        </div>
                        <div class="canvas-card">
                            <div class="canvas-title">Hardware Dock</div>
                            <p class="canvas-text">Detected cameras and controllers render as modules so you can reason about availability before deploying changes.</p>
                        </div>
                    </div>
                </section>

                <div id="status-message" class="inline-status hidden"></div>
            </main>

            <aside class="agent-rail">
                <div class="rail-header">
                    <div>
                        <div class="panel-eyebrow">Continuon AI Agent Manager</div>
                        <div class="rail-title">Threads & Guidance</div>
                        <div id="persona-badge" class="persona-badge">Persona: default</div>
                    </div>
                    <div class="human-toggle" id="human-toggle" onclick="toggleHumanMode()">
                        <span>Human mode</span>
                        <strong id="human-toggle-state">Off</strong>
                    </div>
                </div>

                <div class="rail-actions">
                    <button class="rail-btn primary" onclick="resumeAgents()">‚ñ∂Ô∏è Resume agents</button>
                    <button class="rail-btn" onclick="pauseAgents()">‚è∏Ô∏è Pause agents</button>
                    <button class="rail-btn" onclick="reviewLearning()">üìí Review learning</button>
                </div>

                <div class="panel panel-ghost">
                    <div class="panel-eyebrow">Active Agents</div>
                    <div class="agent-thread-list" id="agent-thread-list"></div>
                </div>

                <div class="panel panel-ghost">
                    <div class="panel-eyebrow">Model Stack & Fallbacks</div>
                    <div class="stack-list" id="model-stack-list"></div>
                </div>

                <div class="panel panel-ghost">
                    <div class="panel-eyebrow">Sub-agents & Tools</div>
                    <div class="stack-list" id="toolchain-list"></div>
                </div>

                <div class="panel panel-ghost">
                    <div class="panel-eyebrow">Training & Memories</div>
                    <div class="stack-list" id="training-memory-list"></div>
                </div>

                <div class="panel panel-ghost">
                    <div class="panel-eyebrow">Robot Mode Self-Learning</div>
                    <div class="milestone-list" id="learning-milestones"></div>
                </div>

                <div class="panel panel-ghost">
                    <div class="panel-eyebrow">Recent Learning Events</div>
                    <div class="learning-list" id="learning-events"></div>
                </div>
            </aside>
        </div>
    </div>

    <div class="modal-backdrop" id="settings-backdrop"></div>
    <div class="settings-modal" id="settings-modal" aria-hidden="true" role="dialog" aria-labelledby="settings-title">
        <div class="modal-card">
            <div class="modal-header">
                <h3 class="modal-title" id="settings-title">Runtime Settings</h3>
                <button class="close-btn" type="button" onclick="closeSettingsModal()">‚úï</button>
            </div>

            <form id="settings-form">
                <div class="settings-grid">
                    <div class="settings-card">
                        <h4>Safety Gates</h4>
                        <div class="settings-row">
                            <label for="settings-allow-motion">Allow motion</label>
                            <input type="checkbox" id="settings-allow-motion">
                        </div>
                        <div class="settings-row">
                            <label for="settings-record-episodes">Record episodes</label>
                            <input type="checkbox" id="settings-record-episodes">
                        </div>
                        <div class="settings-row">
                            <label for="settings-require-supervision">Require supervision</label>
                            <input type="checkbox" id="settings-require-supervision">
                        </div>
                    </div>

                    <div class="settings-card">
                        <h4>Telemetry</h4>
                        <div class="settings-row">
                            <label for="telemetry-rate">Broadcast rate (Hz)</label>
                            <input type="number" id="telemetry-rate" min="0.1" max="30" step="0.1" value="2.0">
                        </div>
                    </div>

                    <div class="settings-card">
                        <h4>Chat Persona</h4>
                        <div class="settings-row">
                            <label for="chat-persona">Role</label>
                            <select id="chat-persona">
                                <option value="operator">Operator</option>
                                <option value="safety_officer">Safety Officer</option>
                                <option value="demo_host">Demo Host</option>
                            </select>
                        </div>
                        <div class="settings-row">
                            <label for="chat-temperature">Response creativity</label>
                            <input type="number" id="chat-temperature" min="0" max="1" step="0.05" value="0.35">
                        </div>
                    </div>
                </div>

                <div class="modal-actions">
                    <button type="button" class="btn" onclick="closeSettingsModal()">Cancel</button>
                    <button type="submit" class="btn primary">Save</button>
                </div>
                <div class="modal-status" id="settings-status">Changes are persisted to your config directory.</div>
            </form>
        </div>
    </div>

    <!-- Chat Interface -->
    <div class="chat-overlay" id="chat-panel">
        <div class="chat-header">
            <h3>Continuon AI Agent Manager</h3>
            <button class="chat-toggle" id="chat-toggle" onclick="toggleChat()" aria-label="Toggle chat panel">‚àí</button>
        </div>
        <div class="chat-messages" id="chat-messages">
        </div>
        <div class="chat-input-area">
            <input type="text" class="chat-input" id="chat-input" placeholder="Ask about robot status, control tips..." aria-label="Chat message input" onkeypress="if(event.key==='Enter') sendChatMessage()">
            <button class="chat-send-btn" id="chat-send" onclick="sendChatMessage()">‚û§</button>
        </div>
    </div>
    <script src="/static/client.js"></script>
    <script type="text/javascript">
        // Tab switching for Home Page
        window.switchHomeTab = function(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                if(btn.dataset.tab === tabName) btn.classList.add('active');
                else btn.classList.remove('active');
            });

            document.querySelectorAll('.home-panel').forEach(panel => {
                if(panel.id === tabName + '-panel') panel.style.display = 'block';
                else panel.style.display = 'none';
            });
        };
        // Global functions for onclick handlers
        window.showMessage = function(message, isError) {
            if (typeof isError === 'undefined') { isError = false; }
            var msgDiv = document.getElementById('status-message');
            msgDiv.textContent = message;
            msgDiv.style.display = 'block';
            msgDiv.style.background = isError ? '#ff3b30' : '#34c759';
            msgDiv.style.color = 'white';
            msgDiv.style.textAlign = 'center';
            setTimeout(function() {
                msgDiv.style.display = 'none';
            }, 3000);
        };

        const settingsModal = document.getElementById('settings-modal');
        const settingsBackdrop = document.getElementById('settings-backdrop');
        const settingsForm = document.getElementById('settings-form');
        const settingsStatus = document.getElementById('settings-status');

        function setSettingsStatus(message, isError) {
            if (!settingsStatus) return;
            settingsStatus.textContent = message;
            settingsStatus.style.color = isError ? '#ff7b7b' : 'var(--muted)';
        }

        function populateSettingsForm(settings) {
            document.getElementById('settings-allow-motion').checked = !!settings?.safety?.allow_motion;
            document.getElementById('settings-record-episodes').checked = !!settings?.safety?.record_episodes;
            document.getElementById('settings-require-supervision').checked = !!settings?.safety?.require_supervision;
            document.getElementById('telemetry-rate').value = settings?.telemetry?.rate_hz ?? 2.0;
            document.getElementById('chat-persona').value = settings?.chat?.persona ?? 'operator';
            document.getElementById('chat-temperature').value = settings?.chat?.temperature ?? 0.35;
        }

        async function fetchSettings() {
            const response = await fetch('/api/settings');
            if (!response.ok) {
                throw new Error('Server responded with ' + response.status);
            }
            const payload = await response.json();
            if (!payload.success) {
                throw new Error(payload.message || 'Unable to load settings');
            }
            return payload.settings || {};
        }

        window.openSettingsModal = async function() {
            settingsModal?.classList.add('open');
            settingsBackdrop?.classList.add('open');
            settingsModal?.setAttribute('aria-hidden', 'false');
            setSettingsStatus('Loading current settings...');

            try {
                const settings = await fetchSettings();
                populateSettingsForm(settings);
                setSettingsStatus('Loaded from config directory.');
            } catch (err) {
                console.error(err);
                setSettingsStatus(err.message || 'Failed to load settings', true);
            }
        };

        window.closeSettingsModal = function() {
            settingsModal?.classList.remove('open');
            settingsBackdrop?.classList.remove('open');
            settingsModal?.setAttribute('aria-hidden', 'true');
        };

        settingsBackdrop?.addEventListener('click', closeSettingsModal);

        settingsForm?.addEventListener('submit', async function(event) {
            event.preventDefault();

            const telemetryRate = parseFloat(document.getElementById('telemetry-rate').value);
            const chatTemperature = parseFloat(document.getElementById('chat-temperature').value);

            if (Number.isNaN(telemetryRate) || telemetryRate <= 0 || telemetryRate > 30) {
                setSettingsStatus('Telemetry rate must be between 0.1 and 30 Hz', true);
                return;
            }

            if (Number.isNaN(chatTemperature) || chatTemperature < 0 || chatTemperature > 1) {
                setSettingsStatus('Chat temperature must be between 0 and 1', true);
                return;
            }

            const payload = {
                safety: {
                    allow_motion: document.getElementById('settings-allow-motion').checked,
                    record_episodes: document.getElementById('settings-record-episodes').checked,
                    require_supervision: document.getElementById('settings-require-supervision').checked,
                },
                telemetry: { rate_hz: telemetryRate },
                chat: {
                    persona: document.getElementById('chat-persona').value,
                    temperature: chatTemperature,
                },
            };

            setSettingsStatus('Saving...');
            try {
                const response = await fetch('/api/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const result = await response.json();

                if (!response.ok || !result.success) {
                    throw new Error(result.message || 'Save failed');
                }

                populateSettingsForm(result.settings || payload);
                setSettingsStatus('Settings saved to config directory.');
                window.showMessage('Settings updated successfully');
                setTimeout(closeSettingsModal, 300);
            } catch (err) {
                console.error('Save failed', err);
                setSettingsStatus(err.message || 'Unable to save settings', true);
                window.showMessage('Unable to save settings', true);
            }
        });

        const agentManagerState = {
            humanMode: false,
            agents: [
                { name: 'Safety Guardian', status: 'active', threads: 2, focus: 'Gates + envelopes', milestone: 'Monitoring' },
                { name: 'Navigator', status: 'active', threads: 1, focus: 'Drive pathfinding', milestone: 'Updating map' },
                { name: 'Trainer', status: 'paused', threads: 1, focus: 'Self-learning batches', milestone: 'Queued' },
            ],
            modelStack: {
                primary: { name: 'HOPE model', role: 'Default Agent Manager', status: 'active', latency: '80 ms', accelerator: 'JAX/CPU' },
                fallbacks: [
                    { name: 'Gemma 3n', role: 'On-device fallback', status: 'ready', latency: '120 ms', accelerator: 'CPU/GPU auto' },
                    { name: 'Cloud LLM', role: 'Long-context fallback', status: 'standby', latency: 'network' },
                ],
            },
            toolchain: [
                { name: 'Safety tools', detail: 'Gates, envelopes, e-stop intents', status: 'ready' },
                { name: 'RLDS curator', detail: 'Episode triage + tagging', status: 'ready' },
                { name: 'Skill linker', detail: 'Chains task to reusable skills', status: 'active' },
            ],
            trainingSummary: {
                episodes: 24,
                pendingImports: 3,
                localMemories: 128,
                lastRun: '12m ago',
                queueState: 'Idle',
            },
            learningEvents: [
                { title: 'Episode flagged for replay', time: '2m ago', detail: 'Marked safe drive lane for offline finetune' },
                { title: 'Gate alignment saved', time: '8m ago', detail: 'Motion + recording gates synced to idle baseline' },
                { title: 'Autonomy pulse', time: '12m ago', detail: 'Wave/particle balance stable; buffer widened' },
            ],
        };

        const taskDeckState = {
            selectedGroup: 'all',
            expandedDetails: {},
            textFilter: '',
        };

        let taskLibraryPayload = null;
        const skillDeckState = {
            textFilter: '',
            skills: [],
        };
        let skillLibraryPayload = null;
        const viewState = {
            mode: 'owner',
        };

        function renderAgentChips(agents) {
            const chipRow = document.getElementById('agent-chip-row');
            if (!chipRow) return;

            chipRow.innerHTML = agents.map(agent => {
                const normalizedStatus = (agent.status || 'active').toLowerCase();
                return `<span class="status-chip ${normalizedStatus}"><span class="badge-dot"></span>${agent.name} ‚Äî ${agent.threads || 1} thread${(agent.threads || 1) > 1 ? 's' : ''}</span>`;
            }).join('');
        }

        function renderModelStack(status) {
            const container = document.getElementById('model-stack-list');
            if (!container) return;

            const stack = (status && status.model_stack) || agentManagerState.modelStack || {};
            const primary = stack.primary || { name: 'Gemma 3n Agent Manager', role: 'On-device', status: 'active', latency: '‚Äî' };
            const fallbacks = Array.isArray(stack.fallbacks) ? stack.fallbacks : [];
            const items = [
                { ...primary, primary: true },
                ...fallbacks,
            ];

            if (!items.length) {
                container.innerHTML = '<div class="stack-item"><span class="stack-meta">No models detected</span></div>';
                return;
            }

            container.innerHTML = items.map(item => {
                const statusChip = `<span class="status-chip ${item.status || 'active'}">${(item.status || '').toUpperCase() || 'ACTIVE'}</span>`;
                const flags = [item.role, item.latency, item.accelerator].filter(Boolean).map(flag => `<span class="task-tag">${flag}</span>`).join('');
                return `<div class="stack-item ${item.primary ? 'primary' : ''}">` +
                    `<div>` +
                        `<h4>${item.name || 'Model'}</h4>` +
                        `<div class="stack-meta">${item.description || 'Primary + fallback routing for Agent Manager'}</div>` +
                        (flags ? `<div class="stack-flags">${flags}</div>` : '') +
                    `</div>` +
                    `<div>${statusChip}</div>` +
                `</div>`;
            }).join('');
        }

        function renderToolchain(status) {
            const container = document.getElementById('toolchain-list');
            if (!container) return;

            const tools = (status && status.toolchain) || agentManagerState.toolchain || [];
            if (!tools.length) {
                container.innerHTML = '<div class="stack-item"><span class="stack-meta">No sub-agents/tools registered</span></div>';
                return;
            }

            container.innerHTML = tools.map(tool => {
                const statusChip = `<span class="status-chip ${tool.status || 'info'}">${(tool.status || 'info').toUpperCase()}</span>`;
                const flags = [tool.detail, tool.scope].filter(Boolean).map(flag => `<span class="task-tag">${flag}</span>`).join('');
                return `<div class="stack-item">` +
                    `<div>` +
                        `<h4>${tool.name || 'Tool'}</h4>` +
                        `<div class="stack-meta">${tool.detail || 'Sub-agent or tool connector'}</div>` +
                        (flags ? `<div class="stack-flags">${flags}</div>` : '') +
                    `</div>` +
                    `<div>${statusChip}</div>` +
                `</div>`;
            }).join('');
        }

        function renderTrainingSummary(status) {
            const container = document.getElementById('training-memory-list');
            if (!container) return;

            const summary = (status && status.training) || agentManagerState.trainingSummary || {};
            const metrics = [
                { label: 'RLDS episodes', value: summary.episodes ?? '‚Äî' },
                { label: 'Pending imports', value: summary.pendingImports ?? '‚Äî' },
                { label: 'Local memories', value: summary.localMemories ?? '‚Äî' },
                { label: 'Last run', value: summary.lastRun || 'n/a' },
                { label: 'Queue state', value: summary.queueState || 'Idle' },
            ];

            container.innerHTML = metrics.map(metric => {
                return `<div class="metric-row">` +
                    `<div class="metric-label">${metric.label}</div>` +
                    `<div class="metric-value">${metric.value}</div>` +
                `</div>`;
            }).join('');
        }

        function renderAgentThreads(agents) {
            const list = document.getElementById('agent-thread-list');
            if (!list) return;

            if (!agents || !agents.length) {
                list.innerHTML = '<div class="agent-thread"><span class="agent-meta">No active agents</span></div>';
                return;
            }

            list.innerHTML = agents.map(agent => {
                const normalizedStatus = (agent.status || 'active').toLowerCase();
                const chip = `<span class="status-chip ${normalizedStatus}">${normalizedStatus === 'active' ? 'üü¢' : '‚è∏Ô∏è'} ${normalizedStatus}</span>`;
                return `<div class="agent-thread">` +
                    `<div>` +
                        `<h4>${agent.name || 'Agent'}</h4>` +
                        `<div class="agent-meta">${agent.focus || 'Monitoring'} ‚Ä¢ ${agent.threads || 1} thread${(agent.threads || 1) > 1 ? 's' : ''}</div>` +
                    `</div>` +
                    `<div>${chip}</div>` +
                `</div>`;
            }).join('');
        }

        function renderLearningMilestones(status) {
            const container = document.getElementById('learning-milestones');
            if (!container) return;

            const gateSnapshot = status.gate_snapshot || status.gates || {};
            const modeLabel = (status.mode || 'idle').replace(/_/g, ' ');
            const uptime = gateSnapshot.mode_uptime_seconds || 0;
            const progress = Math.min(100, Math.round((uptime % 180) / 180 * 100));

            const milestones = [
                { label: 'Motion gate open', done: !!gateSnapshot.allow_motion, detail: gateSnapshot.allow_motion ? 'Ready to move' : 'Waiting for clearance' },
                { label: 'Recording allowed', done: !!gateSnapshot.record_episodes, detail: gateSnapshot.record_episodes ? 'Episodes gated in' : 'Recording gated off' },
                { label: 'Self-train enabled', done: !!gateSnapshot.self_train, detail: gateSnapshot.self_train ? 'Robot learning live' : 'Manual/human-in-loop' },
                { label: `${modeLabel} uptime`, done: progress > 40, detail: `${Math.round(uptime)}s in mode`, progress },
            ];

            container.innerHTML = milestones.map(item => {
                const chipClass = item.done ? 'status-chip active' : 'status-chip paused';
                const progressBar = typeof item.progress === 'number'
                    ? `<div class="progress-bar"><div class="progress-fill" style="width:${item.progress}%"></div></div>`
                    : '';
                return `<div class="milestone-row">` +
                    `<div>` +
                        `<div>${item.label}</div>` +
                        `<div class="learning-meta">${item.detail}</div>` +
                        `${progressBar}` +
                    `</div>` +
                    `<span class="${chipClass}">${item.done ? '‚úÖ' : '‚Ä¶'} ${item.done ? 'Complete' : 'Pending'}</span>` +
                `</div>`;
            }).join('');
        }

        function renderLearningEvents(events) {
            const list = document.getElementById('learning-events');
            if (!list) return;
            const items = events && events.length ? events : [{ title: 'No learning events yet', time: '', detail: 'Agents will surface new checkpoints here.' }];

            list.innerHTML = items.map(event => {
                return `<div class="learning-item">` +
                    `<strong>${event.title}</strong>` +
                    `<div class="learning-meta">${event.detail || 'Update pending'}</div>` +
                    (event.time ? `<div class="learning-meta">${event.time}</div>` : '') +
                `</div>`;
            }).join('');
        }

        function renderSelectedTask(selectedTask) {
            const pill = document.getElementById('current-task-pill');
            if (!pill) return;

            if (!selectedTask || !selectedTask.entry) {
                pill.textContent = 'No task selected';
                pill.className = 'selected-task-pill warning';
                return;
            }

            const entry = selectedTask.entry;
            const eligible = entry.eligibility ? entry.eligibility.eligible : false;
            pill.textContent = `${entry.title || 'Task'} ‚Ä¢ ${entry.group || 'Task Library'}`;
            pill.className = 'selected-task-pill ' + (eligible ? 'success' : 'warning');
        }

        function renderTaskLibrary(payload) {
            const container = document.getElementById('task-groups');
            const controls = document.getElementById('task-group-segments');
            taskLibraryPayload = payload || null;
            if (!container) return;

            const tasks = (payload && payload.tasks) || [];
            const selectedId = payload ? payload.selected_task_id : null;
            if (!tasks.length) {
                container.innerHTML = '<div class="status-item"><span class="status-label">No tasks available</span></div>';
                if (controls) { controls.innerHTML = ''; }
                return;
            }

            const groups = {};
            const filterText = (taskDeckState.textFilter || '').trim();
            tasks.forEach(task => {
                const groupKey = task.group || 'Tasks';
                if (!groups[groupKey]) {
                    groups[groupKey] = [];
                }
                if (!filterText || (task.title && task.title.toLowerCase().includes(filterText)) || (task.description && task.description.toLowerCase().includes(filterText))) {
                    groups[groupKey].push(task);
                }
            });

            const groupEntries = Object.entries(groups);
            const groupLabels = groupEntries.map(([label]) => label);

            if (controls) {
                controls.innerHTML = ['all', ...groupLabels].map(label => {
                    const active = taskDeckState.selectedGroup === label;
                    const displayLabel = label === 'all' ? 'All' : label;
                    return `<button class="${active ? 'active' : ''}" data-group="${label}" onclick="window.filterTaskGroup('${label}')">${displayLabel}</button>`;
                }).join('');
            }

            container.innerHTML = groupEntries.map(([groupLabel, entries]) => {
                const cards = entries.map(task => {
                    const eligibility = task.eligibility || {};
                    const markers = (eligibility.markers || []).map(marker => {
                        const severity = marker.blocking ? 'blocking' : (marker.severity || 'info');
                        const remediation = marker.remediation ? ` ‚Äî ${marker.remediation}` : '';
                        const label = marker.label || marker.code || 'marker';
                        return `<div class="eligibility-marker ${severity}">${label}${remediation}</div>`;
                    }).join('') || '<div class="eligibility-marker success">Eligible</div>';

                    const tagRow = (task.tags || []).map(tag => `<span class="task-tag">${tag}</span>`).join('');
                    const isSelected = selectedId && selectedId === task.id;
                    const selectLabel = isSelected ? 'Selected' : 'Select task';
                    const isEligible = eligibility.eligible !== false;
                    const disabledAttr = isEligible ? '' : 'disabled';
                    const highlightStyle = isSelected ? 'style="border-color: rgba(122,215,255,0.7);"' : '';
                    const detailOpen = !!taskDeckState.expandedDetails[task.id];
                    const detailLabel = detailOpen ? 'Hide details' : 'Details';
                    const detailMeta = [task.estimated_duration, task.recommended_mode].filter(Boolean).join(' ‚Ä¢ ');

                    return `<div class="task-card ${isSelected ? 'selected' : ''} ${detailOpen ? 'expanded' : ''}" ${highlightStyle}>` +
                        `<div>` +
                            `<h3>${task.title || 'Task'}</h3>` +
                            `<div class="task-description">${task.description || ''}</div>` +
                        `</div>` +
                        `<div class="task-actions">` +
                            `<button onclick="window.selectTask('${task.id}')" ${disabledAttr}>${selectLabel}</button>` +
                            `<button class="ghost" onclick="window.toggleTaskDetails('${task.id}')">${detailLabel}</button>` +
                            `<div class="agent-shortcuts">` +
                                `<span class="task-tag">Model: <span id="agent-model-chip">${localStorage.getItem('agent_manager_model') || 'gemma-3n'}</span></span>` +
                                `<button class="ghost" onclick="window.openAgentMenu('${task.id}')">Agent menu</button>` +
                            `</div>` +
                        `</div>` +
                        `<div class="task-detail-drawer ${detailOpen ? 'open' : ''}" id="task-detail-${task.id}">` +
                            `<div class="task-meta">${detailMeta || 'No timing hints'}</div>` +
                            `${tagRow ? `<div class="task-tags">${tagRow}</div>` : ''}` +
                            `<div class="eligibility-stack">${markers}</div>` +
                        `</div>` +
                    `</div>`;
                }).join('');

                const isVisible = taskDeckState.selectedGroup === 'all' || taskDeckState.selectedGroup === groupLabel;
                const openAttr = taskDeckState.selectedGroup === groupLabel ? 'open' : '';
                const hiddenStyle = isVisible ? '' : 'style="display:none;"';

                return `<details class="task-group" data-group="${groupLabel}" ${openAttr} ${hiddenStyle}>` +
                    `<summary>` +
                        `<div>` +
                            `<div class="panel-eyebrow">${groupLabel}</div>` +
                            `<h3>${entries.length} task${entries.length === 1 ? '' : 's'}</h3>` +
                        `</div>` +
                        `<div class="status-chip info">${taskDeckState.selectedGroup === groupLabel ? 'Focused' : 'Browse'}</div>` +
                    `</summary>` +
                    `<div class="task-panel-grid">${cards}</div>` +
                `</details>`;
            }).join('');
        }

        window.filterTaskGroup = function(group) {
            taskDeckState.selectedGroup = group || 'all';
            renderTaskLibrary(taskLibraryPayload || {});
        };

        window.filterTaskText = function(text) {
            taskDeckState.textFilter = (text || '').toLowerCase();
            renderTaskLibrary(taskLibraryPayload || {});
        };

        window.setViewMode = function(mode) {
            viewState.mode = mode === 'research' ? 'research' : 'owner';
            localStorage.setItem('studio_view_mode', viewState.mode);
            const ownerPanels = document.querySelectorAll('.owner-only');
            const researchPanels = document.querySelectorAll('.research-only');
            ownerPanels.forEach(p => p.style.display = viewState.mode === 'owner' ? '' : 'none');
            researchPanels.forEach(p => p.style.display = viewState.mode === 'research' ? '' : 'none');
            const ownerBtn = document.getElementById('owner-view-btn');
            const researchBtn = document.getElementById('research-view-btn');
            if (ownerBtn && researchBtn) {
                ownerBtn.classList.toggle('active', viewState.mode === 'owner');
                researchBtn.classList.toggle('active', viewState.mode === 'research');
            }
        };

        (function initViewMode() {
            const saved = localStorage.getItem('studio_view_mode');
            if (saved) {
                window.setViewMode(saved);
            } else {
                window.setViewMode(viewState.mode);
            }
        })();

        window.toggleTaskDetails = function(taskId) {
            if (!taskId) return;
            taskDeckState.expandedDetails[taskId] = !taskDeckState.expandedDetails[taskId];
            renderTaskLibrary(taskLibraryPayload || {});
        };

        function renderAgentRail(status) {
            const agents = (status && Array.isArray(status.agent_threads) && status.agent_threads.length)
                ? status.agent_threads
                : agentManagerState.agents;

            const events = (status && Array.isArray(status.learning_events) && status.learning_events.length)
                ? status.learning_events
                : agentManagerState.learningEvents;

            const managerStatus = (status && (status.agent_manager || status.agent_manager_status)) || {};

            renderAgentThreads(agents);
            renderAgentChips(agents);
            renderModelStack(managerStatus);
            renderToolchain(managerStatus);
            renderTrainingSummary(managerStatus);
            renderLearningMilestones(status || {});
            renderLearningEvents(events);

            const toggle = document.getElementById('human-toggle');
            const toggleState = document.getElementById('human-toggle-state');
            const personaBadgeEl = document.getElementById('persona-badge');
            if (personaBadgeEl) {
                const persona = managerStatus.persona || 'default';
                personaBadgeEl.textContent = `Persona: ${persona}`;
            }
            if (toggle) {
                toggle.classList.toggle('active', agentManagerState.humanMode);
            }
            if (toggleState) {
                toggleState.textContent = agentManagerState.humanMode ? 'On' : 'Off';
            }

            // Persona badge from saved persona sliders
            if (personaBadgeEl) {
                try {
                    const saved = localStorage.getItem('agent_persona');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        const persona = parsed.persona || 'default';
                        const style = parsed.response_style || 'concise';
                        personaBadgeEl.textContent = `Persona: ${persona} ‚Ä¢ ${style}`;
                    }
                } catch (err) {
                    console.warn('Failed to read persona badge', err);
                }
            }
        }

        function renderModeList(status) {
            const container = document.getElementById('mode-pill-container');
            if (!container) return;
            const current = (status && status.mode) || 'unknown';
            const modes = [
                { id: 'idle', label: 'Idle' },
                { id: 'manual_control', label: 'Manual Control' },
                { id: 'manual_training', label: 'Manual Training' },
                { id: 'autonomous', label: 'Autonomous' },
                { id: 'sleep_learning', label: 'Sleep Learning' },
                { id: 'emergency_stop', label: 'Emergency Stop' },
            ];
            container.innerHTML = modes.map(m => {
                const isCurrent = current === m.id;
                return `<span class="mode-pill ${isCurrent ? 'current' : ''}">${m.label}</span>`;
            }).join('');

            const stackChip = document.getElementById('model-stack-chip');
            if (stackChip) {
                const stack = (status && status.model_stack) || agentManagerState.modelStack || {};
                const primary = stack.primary?.name || 'HOPE v0';
                const fallbacks = (stack.fallbacks || []).map(f => f.name).filter(Boolean);
                const summary = [primary, ...fallbacks].join(' ‚Üí ') || 'HOPE ‚Üí Gemini ‚Üí Gemma';
                stackChip.textContent = 'Model stack: ' + summary;
            }
        }

        window.toggleHumanMode = function() {
            agentManagerState.humanMode = !agentManagerState.humanMode;
            window.showMessage(agentManagerState.humanMode ? 'Human guidance injected' : 'Human mode disabled');
            renderAgentRail();
        };

        window.pauseAgents = function() {
            agentManagerState.agents = agentManagerState.agents.map(agent => ({ ...agent, status: 'paused' }));
            window.showMessage('Agents paused for inspection');
            renderAgentRail();
        };

        window.resumeAgents = function() {
            agentManagerState.agents = agentManagerState.agents.map(agent => ({ ...agent, status: 'active' }));
            window.showMessage('Agents resumed');
            renderAgentRail();
        };

        window.reviewLearning = function() {
            window.showMessage('Learning feed refreshed');
            renderAgentRail();
            const events = document.getElementById('learning-events');
            if (events) {
                events.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        };

        window.triggerSafetyHold = async function() {
            window.showMessage('Engaging safety hold...');
            try {
                const response = await fetch('/api/safety/hold', { method: 'POST' });
                const data = await response.json();
                if (data && data.success) {
                    window.showMessage('Safety hold engaged');
                    window.updateStatus();
                } else {
                    window.showMessage('Hold failed', true);
                }
            } catch (err) {
                console.error(err);
                window.showMessage('Hold request failed', true);
            }
        };

        window.resetSafetyGates = async function() {
            window.showMessage('Resetting gates to idle baseline...');
            try {
                const response = await fetch('/api/safety/reset', { method: 'POST' });
                const data = await response.json();
                if (data && data.success) {
                    window.showMessage('Gates reset to idle');
                    window.updateStatus();
                } else {
                    window.showMessage('Reset failed', true);
                }
            } catch (err) {
                console.error(err);
                window.showMessage('Reset request failed', true);
            }
        };

        function renderLoopTelemetry(status) {
            var loops = status.loop_metrics || status.metrics || {};
            var gates = status.gate_snapshot || status.gates || {};
            var safety = status.safety_head || {};

            var wave = (typeof loops.wave_particle_balance === 'number') ? Math.min(1, Math.max(0, loops.wave_particle_balance)) : 0;
            var waveFill = document.getElementById('wave-meter');
            if (waveFill) {
                waveFill.style.width = Math.round(wave * 100) + '%';
            }
            var waveLabel = document.getElementById('wave-value');
            if (waveLabel) {
                var wavePercent = Math.round(wave * 100);
                waveLabel.textContent = wavePercent + '% wave / ' + (100 - wavePercent) + '% particle';
            }

            var hope = loops.hope_loops || {};
            var fast = hope.fast || {};
            var mid = hope.mid || {};
            var slow = hope.slow || {};
            var hopeFast = document.getElementById('hope-fast');
            if (hopeFast) { hopeFast.textContent = 'Fast: ' + (fast.hz ? fast.hz + ' Hz (' + fast.latency_ms + ' ms)' : '--'); }
            var hopeMid = document.getElementById('hope-mid');
            if (hopeMid) { hopeMid.textContent = 'Mid: ' + (mid.hz ? mid.hz + ' Hz (' + mid.latency_ms + ' ms)' : '--'); }
            var hopeSlow = document.getElementById('hope-slow');
            if (hopeSlow) { hopeSlow.textContent = 'Slow: ' + (slow.hz ? slow.hz + ' Hz (' + slow.latency_ms + ' ms)' : '--'); }

            var cms = loops.cms || {};
            var cmsRatio = document.getElementById('cms-ratio');
            if (cmsRatio) {
                cmsRatio.textContent = cms.policy_ratio ? 'Policy ' + cms.policy_ratio + ' | Maintenance ' + cms.maintenance_ratio : '--';
            }
            var cmsBuffer = document.getElementById('cms-buffer');
            if (cmsBuffer) {
                cmsBuffer.textContent = cms.buffer_fill ? 'Buffer fill: ' + Math.round(cms.buffer_fill * 100) + '%' : 'Buffer fill: --';
            }

            var heartbeat = loops.heartbeat || {};
            var heartbeatBadge = document.getElementById('heartbeat-badge');
            if (heartbeatBadge) {
                var beatAgeMs = heartbeat.last_beat ? (Date.now() - heartbeat.last_beat * 1000) : null;
                var beatAgeLabel = beatAgeMs ? ' ‚Ä¢ ' + Math.round(beatAgeMs) + 'ms ago' : '';
                heartbeatBadge.textContent = heartbeat.ok ? 'Heartbeat stable' + beatAgeLabel : 'Heartbeat delayed';
                heartbeatBadge.className = 'chip ' + (heartbeat.ok ? 'success' : 'danger');
            }

            var gateAllow = document.getElementById('gate-allow');
            if (gateAllow) { gateAllow.textContent = gates.allow_motion ? 'Open' : 'Locked'; }
            var gateRecord = document.getElementById('gate-record');
            if (gateRecord) { gateRecord.textContent = gates.recording_gate ? 'Armed' : 'Off'; }

            var safetyHead = document.getElementById('safety-head-path');
            if (safetyHead) { safetyHead.textContent = safety.head_path || 'stub'; }
            var safetyEnvelope = document.getElementById('safety-envelope');
            if (safetyEnvelope) {
                var env = safety.envelope || {};
                safetyEnvelope.textContent = (env.status || 'simulated') + ' ‚Ä¢ ' + (env.radius_m || '?') + 'm radius';
            }
            var safetyHeartbeat = document.getElementById('safety-heartbeat');
            if (safetyHeartbeat) {
                var safetyBeat = safety.heartbeat || {};
                var beatDelta = safetyBeat.timestamp_ns ? ((Date.now() * 1e6 - safetyBeat.timestamp_ns) / 1e9).toFixed(1) : null;
                var beatLabel = beatDelta ? ' ‚Ä¢ ' + beatDelta + 's ago' : '';
                safetyHeartbeat.textContent = safetyBeat.ok ? 'Online (' + (safetyBeat.source || 'safety') + beatLabel + ')' : 'Simulated';
            }
        }

        window.selectTask = async function(taskId) {
            if (!taskId) return;
            try {
                const response = await fetch('/api/tasks/select', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ task_id: taskId, reason: 'studio-selection' })
                });
                if (!response.ok) {
                    throw new Error('HTTP ' + response.status);
                }
                const payload = await response.json();
                window.showMessage(payload.message || 'Task selection updated', !payload.accepted);
                if (payload.selected_task) {
                    renderSelectedTask({ entry: payload.selected_task });
                }
                window.fetchTaskLibrary();
                window.updateStatus();
            } catch (err) {
                console.warn('Task selection failed', err);
                window.showMessage('Failed to select task', true);
            }
        };

        window.applyTaskLibraryPayload = function(payload) {
            if (!payload) return;
            renderTaskLibrary(payload);
            if (payload && payload.selected_task_id && Array.isArray(payload.tasks)) {
                const selected = payload.tasks.find(task => task.id === payload.selected_task_id);
                if (selected) {
                    renderSelectedTask({ entry: selected });
                }
            }
        }

        window.fetchTaskLibrary = async function(payload) {
            if (payload) {
                window.applyTaskLibraryPayload(payload);
                return;
            }
            try {
                const response = await fetch('/api/tasks?include_ineligible=true');
                if (!response.ok) { return; }
                const json = await response.json();
                window.applyTaskLibraryPayload(json);
            } catch (err) {
                console.warn('Task library fetch failed', err);
            }
        };

        window.applySkillLibraryPayload = function(payload) {
            const container = document.getElementById('skill-groups');
            if (!container) return;
            const skills = (payload && payload.skills) || [];
            skillDeckState.skills = skills;
            skillLibraryPayload = payload;
            const filterText = (skillDeckState.textFilter || '').trim();
            if (!skills.length) {
                container.innerHTML = '<div class="status-item"><span class="status-label">No skills available</span></div>';
                return;
            }
            const pinned = localStorage.getItem('pinned_skill');
            const pinnedPill = document.getElementById('pinned-skill-pill');
            if (pinnedPill) {
                pinnedPill.textContent = 'Pinned skill: ' + (pinned || 'none');
            }

            const groups = {};
            skills.forEach(skill => {
                const groupKey = skill.group || 'Skills';
                if (!groups[groupKey]) groups[groupKey] = [];
                if (!filterText || (skill.title && skill.title.toLowerCase().includes(filterText)) || (skill.description && skill.description.toLowerCase().includes(filterText))) {
                    groups[groupKey].push(skill);
                }
            });

            container.innerHTML = Object.entries(groups).map(([groupLabel, entries]) => {
                const cards = entries.map(skill => {
                    const eligibility = skill.eligibility || {};
                    const markers = (eligibility.markers || []).map(marker => {
                        const severity = marker.blocking ? 'blocking' : (marker.severity || 'info');
                        const remediation = marker.remediation ? ` ‚Äî ${marker.remediation}` : '';
                        const label = marker.label || marker.code || 'marker';
                        return `<div class="eligibility-marker ${severity}">${label}${remediation}</div>`;
                    }).join('') || '<div class="eligibility-marker success">Eligible</div>';

                    const tagRow = (skill.tags || []).map(tag => `<span class="task-tag">${tag}</span>`).join('');
                    const capRow = (skill.capabilities || []).map(cap => `<span class="task-tag">${cap}</span>`).join('');

                    return `
                        <div class="skill-card">
                            <h3>${skill.title || 'Skill'}</h3>
                            <div class="task-description">${skill.description || ''}</div>
                            <div class="skill-meta">
                                <span>Publisher: ${skill.publisher || 'local'}</span>
                                <span>v${skill.version || '0.1.0'}</span>
                            </div>
                            <div class="task-tags">${tagRow}</div>
                            <div class="task-tags">${capRow}</div>
                            <div style="margin-top:6px;">${markers}</div>
                            <div style="display:flex; gap:6px; flex-wrap:wrap; margin-top:8px;">
                                <button onclick="window.viewSkillSummary('${skill.id}')">Summary</button>
                                <button class="ghost" onclick="window.pinSkill('${skill.id}')">Pin</button>
                            </div>
                        </div>
                    `;
                }).join('');

                return `
                    <div>
                        <div class="panel-eyebrow" style="margin-bottom:4px;">${groupLabel}</div>
                        <div class="skill-grid">${cards}</div>
                    </div>
                `;
            }).join('');
        }

        window.fetchSkillLibrary = async function(payload) {
            if (payload) {
                window.applySkillLibraryPayload(payload);
                return;
            }
            try {
                const response = await fetch('/api/skills?include_ineligible=true');
                if (!response.ok) { return; }
                const json = await response.json();
                window.applySkillLibraryPayload(json);
            } catch (err) {
                console.warn('Skill library fetch failed', err);
            }
        };

        window.filterSkillText = function(text) {
            skillDeckState.textFilter = (text || '').toLowerCase();
            window.applySkillLibraryPayload(skillLibraryPayload || { skills: skillDeckState.skills });
        }

        window.viewSkillSummary = async function(skillId) {
            try {
                const res = await fetch(`/api/skills/summary/${skillId}`);
                if (!res.ok) return;
                const payload = await res.json();
                alert(JSON.stringify(payload.summary || payload, null, 2));
            } catch (err) {
                console.warn('Skill summary failed', err);
            }
        };

        window.pinSkill = function(skillId) {
            localStorage.setItem('pinned_skill', skillId);
            window.showMessage('Pinned skill: ' + skillId);
            const pill = document.getElementById('pinned-skill-pill');
            if (pill) {
                pill.textContent = 'Pinned skill: ' + skillId;
            }
        };

        // Tab switching logic for Manual Control
        window.switchTab = function(tabName) {
            // Update tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                if(btn.dataset.tab === tabName) btn.classList.add('active');
                else btn.classList.remove('active');
            });

            // Update panels
            document.querySelectorAll('.control-panel').forEach(panel => {
                if(panel.id === tabName + '-panel') panel.style.display = 'block';
                else panel.style.display = 'none';
            });
        };
        
        window.applyStatusPayload = function(statusPayload) {
            if (!statusPayload) return;
            var status = statusPayload.status ? statusPayload.status : statusPayload;
            var mode = status.mode || 'unknown';
            var modeText = mode.replace(/_/g, ' ').toUpperCase();
            document.getElementById('mode').innerHTML = '<span class="badge ' + mode + '">' + modeText + '</span>';
            document.getElementById('recording').textContent = status.is_recording ? 'Recording' : 'Idle';
            document.getElementById('motion').textContent = status.allow_motion ? 'Motion Enabled' : 'Motion Locked';

            var modeCard = document.getElementById('mode-card');
            if (modeCard) { modeCard.textContent = modeText; }
            var recordingCard = document.getElementById('recording-card');
            if (recordingCard) { recordingCard.textContent = status.is_recording ? 'Recording' : 'Idle'; }
            var motionCard = document.getElementById('motion-card');
            if (motionCard) { motionCard.textContent = status.allow_motion ? 'Allowed' : 'Prevented'; }

            renderLoopTelemetry(status);
            renderAgentRail(status);
            renderSelectedTask(status.current_task);

            // Update hardware sensors
            var hardwareDiv = document.getElementById('hardware-status');
            if (status.detected_hardware) {
                var hw = status.detected_hardware;
                var hwHtml = '';
                
                if (hw.depth_camera) {
                    hwHtml += '<div class="status-item"><span class="status-label">üì∑ Depth Camera</span><span class="status-value">' + hw.depth_camera + '</span></div>';
                }
                if (hw.depth_camera_driver) {
                    hwHtml += '<div class="status-item"><span class="status-label">Camera Driver</span><span class="status-value">' + hw.depth_camera_driver + '</span></div>';
                }
                if (hw.servo_controller) {
                    hwHtml += '<div class="status-item"><span class="status-label">ü¶æ Servo Controller</span><span class="status-value">' + hw.servo_controller + '</span></div>';
                }
                if (hw.servo_controller_address) {
                    hwHtml += '<div class="status-item"><span class="status-label">I2C Address</span><span class="status-value">' + hw.servo_controller_address + '</span></div>';
                }
                
                if (hwHtml) {
                    hardwareDiv.innerHTML = hwHtml;
                } else {
                    hardwareDiv.innerHTML = '<div class="status-item"><span class="status-label">No hardware detected</span></div>';
                }
            } else {
                hardwareDiv.innerHTML = '<div class="status-item"><span class="status-label">Hardware info not available</span></div>';
            }

            renderModeList(status);
        };

        window.updateStatus = function(payload) {
            if (payload) {
                window.applyStatusPayload(payload);
                return;
            }
            var xhr = new XMLHttpRequest();
            xhr.open('GET', '/api/status', true);
            xhr.onload = function() {
                if (xhr.status === 200) {
                    try {
                        var data = JSON.parse(xhr.responseText);
                        if (data.status) {
                            window.applyStatusPayload(data.status);
                        }
                    } catch (e) {
                        console.error('Parse error:', e);
                    }
                }
            };
            xhr.onerror = function() {
                console.error('Connection failed');
                window.showMessage('Failed to connect to robot', true);
            };
            xhr.send();
        };
        
        window.setMode = function(mode) {
            console.log('Setting mode to:', mode);
            window.showMessage('Changing mode to ' + mode.replace(/_/g, ' ') + '...');

            var xhr = new XMLHttpRequest();
            xhr.open('GET', '/api/mode/' + mode, true);
            xhr.onload = function() {
                if (xhr.status === 200) {
                    try {
                        var data = JSON.parse(xhr.responseText);
                        if (data.success) {
                            window.showMessage('Mode changed to ' + mode.replace(/_/g, ' ').toUpperCase());
                            setTimeout(window.updateStatus, 500);
                        } else {
                            window.showMessage('Failed: ' + (data.message || 'Unknown error'), true);
                        }
                    } catch (e) {
                        console.error('Parse error:', e);
                        window.showMessage('Error parsing response', true);
                    }
                } else {
                    window.showMessage('Server error: ' + xhr.status, true);
                }
            };
            xhr.onerror = function() {
                console.error('Connection failed');
                window.showMessage('Connection failed', true);
            };
            xhr.send();
        };

        window.startManualControl = async function(buttonEl) {
            const manualButton = buttonEl || document.getElementById('manual-control-btn');
            if (!manualButton) {
                window.showMessage('Manual Control button not found', true);
                return;
            }

            if (manualButton.disabled) {
                return;
            }

            const originalText = manualButton.textContent;
            manualButton.disabled = true;
            manualButton.textContent = 'Switching...';

            try {
                window.showMessage('Switching to manual control...');
                const response = await fetch('/api/mode/manual_control', { method: 'POST' });
                if (!response.ok) {
                    throw new Error('Server responded with ' + response.status);
                }

                const payload = await response.json();
                if (payload && payload.success) {
                    window.showMessage('Manual control enabled, redirecting...');
                    window.updateStatus();
                    setTimeout(() => { window.location.href = '/control'; }, 300);
                } else {
                    const message = (payload && payload.message) ? payload.message : 'Unable to enable manual control';
                    window.showMessage(message, true);
                    window.updateStatus();
                    manualButton.disabled = false;
                    manualButton.textContent = originalText;
                }
            } catch (err) {
                console.error('Manual control switch failed', err);
                window.showMessage('Failed to switch to manual control', true);
                window.updateStatus();
                manualButton.disabled = false;
                manualButton.textContent = originalText;
            }
        };

        window.applyLoopHealthPayload = function(payload) {
            if (!payload) return;
            const source = payload.metrics || payload.loop_metrics ? payload : payload.status || payload;
            if (source.metrics || source.loop_metrics) {
                renderLoopTelemetry({
                    loop_metrics: source.metrics || source.loop_metrics,
                    gate_snapshot: source.gates || source.gate_snapshot,
                    safety_head: source.safety_head
                });
            }
        }

        window.pollLoopHealth = async function(payload) {
            if (payload) {
                window.applyLoopHealthPayload(payload);
                return;
            }
            try {
                const response = await fetch('/api/loops');
                if (!response.ok) { return; }
                const json = await response.json();
                if (json) {
                    window.applyLoopHealthPayload(json);
                }
            } catch (err) {
                console.warn('Loop telemetry fetch failed', err);
            }
        };

        window.openAgentMenu = function(taskId) {
            const menu = document.createElement('div');
            menu.className = 'task-card expanded';
            menu.style.position = 'fixed';
            menu.style.right = '16px';
            menu.style.bottom = '16px';
            menu.style.zIndex = 9999;
            menu.innerHTML = `
                <h3>Agent Manager</h3>
                <div class="task-description">Context for task ${taskId}</div>
                <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;">
                    <button onclick="window.setAgentModel('gemma-3n')">Gemma 3n</button>
                    <button onclick="window.setAgentModel('gemma-transformer')" class="ghost">Transformers</button>
                    <button onclick="window.setAgentModel('hailo-runtime')" class="ghost">Hailo</button>
                </div>
                <div style="margin-top:10px;">
                    <div class="task-description" style="margin-bottom:6px;">Sub-agents</div>
                    <div style="display:flex; gap:6px; flex-wrap:wrap;">
                        <button class="ghost" onclick="alert('Planner toggled (stub)')">Planner</button>
                        <button class="ghost" onclick="alert('Navigator toggled (stub)')">Navigator</button>
                        <button class="ghost" onclick="alert('Safety toggled (stub)')">Safety</button>
                        <button class="ghost" onclick="alert('Recorder toggled (stub)')">Recorder</button>
                    </div>
                </div>
                <div class="task-description" style="margin-top:10px;">(Local-only stub; wire to backend to persist.)</div>
                <button class="ghost" style="margin-top:10px;" onclick="this.parentElement.remove()">Close</button>
            `;
            document.body.appendChild(menu);
        };

        window.setAgentModel = function(model) {
            localStorage.setItem('agent_manager_model', model);
            const chip = document.getElementById('agent-model-chip');
            if (chip) chip.textContent = model;
            alert('Agent Manager model set (local): ' + model);
        };

        // Chat overlay persistence (shared between /ui and /control)
        var chatMinimized = false;
        var chatHistory = [];
        var chatStoragePrefix = 'gemma_chat_' + (window.location.host || 'local');
        var chatHistoryKey = chatStoragePrefix + '_history';
        var chatMinimizedKey = chatStoragePrefix + '_minimized';

        function persistChatState() {
            try {
                localStorage.setItem(chatHistoryKey, JSON.stringify(chatHistory.slice(-50)));
                localStorage.setItem(chatMinimizedKey, chatMinimized ? 'true' : 'false');
            } catch (e) {
                console.warn('Unable to persist chat state', e);
            }
        }

        function applyChatMinimized() {
            var panel = document.getElementById('chat-panel');
            var toggle = document.getElementById('chat-toggle');
            if (!panel || !toggle) return;

            if (chatMinimized) {
                panel.classList.add('minimized');
                toggle.textContent = '+';
            } else {
                panel.classList.remove('minimized');
                toggle.textContent = '‚àí';
            }
        }


        hydrateChatOverlay();

        // Chat overlay persistence (shared between /ui and /control)
        var chatMinimized = false;
        var chatHistory = [];
        var chatStoragePrefix = 'gemma_chat_' + (window.location.host || 'local');
        var chatHistoryKey = chatStoragePrefix + '_history';
        var chatMinimizedKey = chatStoragePrefix + '_minimized';

        function persistChatState() {
            try {
                localStorage.setItem(chatHistoryKey, JSON.stringify(chatHistory.slice(-50)));
                localStorage.setItem(chatMinimizedKey, chatMinimized ? 'true' : 'false');
            } catch (e) {
                console.warn('Unable to persist chat state', e);
            }
        }

        function applyChatMinimized() {
            var panel = document.getElementById('chat-panel');
            var toggle = document.getElementById('chat-toggle');
            if (!panel || !toggle) return;

            if (chatMinimized) {
                panel.classList.add('minimized');
                toggle.textContent = '+';
            } else {
                panel.classList.remove('minimized');
                toggle.textContent = '‚àí';
            }
        }

        function renderChatMessage(text, role, shouldPersist) {
            if (typeof shouldPersist === 'undefined') shouldPersist = true;

            var messagesDiv = document.getElementById('chat-messages');
            if (!messagesDiv) return;

            var messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message ' + role;
            messageDiv.textContent = text;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            if (shouldPersist) {
                chatHistory.push({role: role, content: text});
                persistChatState();
            }
        }


        hydrateChatOverlay();

        // Chat overlay persistence (/ui + /control)
        var chatMinimized = false;
        var chatHistory = [];
        var chatStoragePrefix = 'gemma_chat_' + (window.location.host || 'local');
        var chatHistoryKey = chatStoragePrefix + '_history';
        var chatMinimizedKey = chatStoragePrefix + '_minimized';
        var MAX_MESSAGE_LENGTH = 10000; // Maximum allowed message length for DoS protection
        var initialChatMessage = 'Chat with Gemma 3n about robot control';

        // Sanitize text to prevent XSS attacks
        function sanitizeText(text) {
            if (typeof text !== 'string') {
                return '';
            }
            
            // Remove any HTML tags first
            var sanitized = text.replace(/<[^>]*>/g, '');
            
            // Remove any remaining < or > characters that might be part of incomplete tags
            sanitized = sanitized.replace(/[<>]/g, '');
            
            // Remove javascript: and data: URL schemes
            sanitized = sanitized.replace(/javascript:/gi, '');
            sanitized = sanitized.replace(/data:/gi, '');
            
            // Remove common XSS event handlers
            sanitized = sanitized.replace(/on\w+\s*=/gi, '');
            
            // Limit length to prevent DOS attacks
            return sanitized.substring(0, 10000);
        }

        function persistChatState() {
            try {
                // Trim in-memory history as well
                if (chatHistory.length > 50) {
                    chatHistory = chatHistory.slice(-50);
                }
                localStorage.setItem(chatHistoryKey, JSON.stringify(chatHistory));
                localStorage.setItem(chatMinimizedKey, chatMinimized ? 'true' : 'false');
            } catch (e) {
                console.warn('Unable to persist chat state', e);
                // Show a user-visible warning
                alert('Warning: Unable to save chat history. Your messages may not be saved.');
            }
        }

        function applyChatMinimized() {
            var panel = document.getElementById('chat-panel');
            var toggle = document.getElementById('chat-toggle');
            if (!panel || !toggle) return;

            if (chatMinimized) {
                panel.classList.add('minimized');
                toggle.textContent = '+';
            } else {
                panel.classList.remove('minimized');
                toggle.textContent = '‚àí';
            }
        }

        function validateChatContent(content) {
            // Validate chat content to prevent injection attacks
            // Ensure content is a string and within reasonable bounds
            if (typeof content !== 'string') return '';
            // Limit message length to prevent DoS
            if (content.length > MAX_MESSAGE_LENGTH) return content.substring(0, MAX_MESSAGE_LENGTH);
            return content;
        }

        function validateChatRole(role) {
            // Validate role to prevent class injection
            var validRoles = ['user', 'assistant', 'system'];
            return validRoles.indexOf(role) !== -1 ? role : 'system';
        }

        function renderChatMessage(text, role, shouldPersist) {
            if (typeof shouldPersist === 'undefined') shouldPersist = true;

            var messagesDiv = document.getElementById('chat-messages');
            if (!messagesDiv) return;

            // Validate inputs to prevent injection attacks
            var validatedText = validateChatContent(text);
            var validatedRole = validateChatRole(role);

            var messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message ' + validatedRole;
            messageDiv.textContent = validatedText; // textContent prevents XSS
            // Sanitize text before rendering
            var sanitized = sanitizeText(text);
            
            var messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message ' + role;
            messageDiv.textContent = sanitized;
            messagesDiv.appendChild(messageDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;

            if (shouldPersist) {
                chatHistory.push({role: validatedRole, content: validatedText});
                chatHistory.push({role: role, content: sanitized});
                persistChatState();
            }
        }

        function hydrateChatOverlay() {
            try {
                var storedHistory = localStorage.getItem(chatHistoryKey);
                if (storedHistory) {
                    try {
                        chatHistory = JSON.parse(storedHistory) || [];
                        if (!Array.isArray(chatHistory)) {
                            chatHistory = [];
                        }
                    } catch (parseError) {
                        console.warn('Failed to parse chat history from localStorage, using empty history instead:', parseError);
                        chatHistory = [];
                    }
                    chatHistory.forEach(function(msg) {
                        if (msg && typeof msg === 'object' && msg.role && msg.content) {
                            renderChatMessage(msg.content, msg.role, false);
                        }
                    });
                } else {
                    chatHistory = [];
                }

                var storedMinimized = localStorage.getItem(chatMinimizedKey);
                if (storedMinimized === 'true') {
                    chatMinimized = true;
                }
            } catch (e) {
                console.warn('Unable to hydrate chat state', e);
                chatHistory = [];
            }

            applyChatMinimized();
        }

        window.toggleChat = function() {
            chatMinimized = !chatMinimized;
            persistChatState();
            applyChatMinimized();
        };

        window.addChatMessage = function(text, role) {
            renderChatMessage(text, role, true);
        };

        window.sendChatMessage = function() {
            var input = document.getElementById('chat-input');
            var sendBtn = document.getElementById('chat-send');
            var message = input ? input.value.trim() : '';

            if (!message) return;

            // Add user message
            addChatMessage(message, 'user');
            if (input) input.value = '';

            // Disable input while processing
            if (input) input.disabled = true;
            if (sendBtn) sendBtn.disabled = true;

            // Send to Gemma endpoint
            var xhr = new XMLHttpRequest();
            xhr.open('POST', '/api/chat', true);
            xhr.setRequestHeader('Content-Type', 'application/json');
            xhr.onload = function() {
                if (input) input.disabled = false;
                if (sendBtn) sendBtn.disabled = false;

                if (xhr.status === 200) {
                    try {
                        var data = JSON.parse(xhr.responseText);
                        if (data.response) {
                            addChatMessage(data.response, 'assistant');
                        } else if (data.error) {
                            addChatMessage('Error: ' + data.error, 'system');
                        }
                    } catch (e) {
                        addChatMessage('Error parsing response', 'system');
                    }
                } else {
                    addChatMessage('Server error: ' + xhr.status, 'system');
                }

                if (input) input.focus();
            };
            xhr.onerror = function() {
                if (input) input.disabled = false;
                if (sendBtn) sendBtn.disabled = false;
                addChatMessage('Connection error', 'system');
                if (input) input.focus();
            };

            // Include chat history for context
            xhr.send(JSON.stringify({
                message: message,
                history: chatHistory.slice(-10) // Last 10 messages for context
            }));
        };

        hydrateChatOverlay();

        // Kick off initial renders
        renderAgentRail();
        window.updateStatus();
        window.pollLoopHealth();
        window.fetchTaskLibrary();
        window.fetchSkillLibrary();

        // Realtime updates via SSE with polling fallback
        if (window.StudioClient && window.StudioClient.startRealtime) {
            window.StudioClient.startRealtime({
                onStatus: (payload) => window.updateStatus(payload),
                onLoops: (payload) => window.pollLoopHealth(payload),
                onTasks: (payload) => window.fetchTaskLibrary(payload),
                onSkills: (payload) => window.fetchSkillLibrary({ skills: payload }),
                fallbackPollMs: 8000,
            });
        } else {
            setInterval(window.updateStatus, 4000);
            setInterval(window.pollLoopHealth, 4000);
            setInterval(window.fetchTaskLibrary, 8000);
            setInterval(window.fetchSkillLibrary, 8000);
        }
    </script>
    <!-- Shared chat overlay enhancements -->
    <script src="/static/chat-overlay.js"></script>
</body>
</html>
